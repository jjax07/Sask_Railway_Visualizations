<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One-Hour Railway Corridor from Saskatoon</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: #16213e;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #e94560;
        }
        .header h1 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .header p {
            color: #aaa;
            max-width: 800px;
            margin: 0 auto;
        }
        .nav {
            background: #0f3460;
            padding: 10px;
            text-align: center;
        }
        .nav a {
            color: #e94560;
            text-decoration: none;
            margin: 0 15px;
            padding: 5px 15px;
            border: 1px solid #e94560;
            border-radius: 3px;
            transition: all 0.3s;
        }
        .nav a:hover {
            background: #e94560;
            color: #fff;
        }
        .container {
            display: flex;
            height: calc(100vh - 160px);
        }
        #map {
            flex: 1;
            height: 100%;
        }
        .sidebar {
            width: 320px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
        }
        .controls {
            margin-bottom: 20px;
        }
        .controls label {
            display: block;
            margin-bottom: 10px;
            color: #e94560;
            font-weight: bold;
        }
        .year-display {
            font-size: 48px;
            text-align: center;
            color: #e94560;
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        .stats {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .stats h3 {
            color: #e94560;
            margin-bottom: 10px;
            border-bottom: 1px solid #e94560;
            padding-bottom: 5px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        .settlement-list {
            margin-top: 20px;
        }
        .settlement-list h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .settlement-item {
            background: #0f3460;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            border-left: 3px solid #e94560;
        }
        .settlement-item .name {
            font-weight: bold;
        }
        .settlement-item .details {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        .legend {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .legend h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .play-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .play-controls button {
            background: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .play-controls button:hover {
            background: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>One-Hour Railway Corridor from Saskatoon</h1>
        <p>Explore which settlements could be reached from Saskatoon within one hour by train (40 km at 40 km/h average speed) as the railway network expanded from 1890 to 1920.</p>
    </div>
    <div class="nav">
        <a href="index.html">Home</a>
        <a href="one_hour_map.html">Saskatoon Corridor</a>
        <a href="settlement_explorer.html">Settlement Explorer</a>
        <a href="railway_timeline.html">Railway Timeline</a>
        <a href="network_graph.html">Network Graph</a>
    </div>
    <div class="container">
        <div id="map"></div>
        <div class="sidebar">
            <div class="controls">
                <label>Select Year:</label>
                <div class="year-display" id="yearDisplay">1890</div>
                <input type="range" id="yearSlider" min="1890" max="1920" step="5" value="1890">
                <div class="play-controls">
                    <button id="playBtn">Play</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>

            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-item">
                    <span>Connected Settlements:</span>
                    <span id="connectedCount">0</span>
                </div>
                <div class="stat-item">
                    <span>Total in Range:</span>
                    <span id="totalCount">0</span>
                </div>
            </div>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #e94560;"></div>
                    <span>Saskatoon</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #4ecca3;"></div>
                    <span>Connected Settlement</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #666; opacity: 0.5;"></div>
                    <span>Not Yet Connected</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: transparent; border: 2px dashed #e94560;"></div>
                    <span>40 km Radius (1 hour)</span>
                </div>
                <div class="legend-item">
                    <div style="width: 20px; height: 3px; background: #4ecca3; margin-right: 10px;"></div>
                    <span>Railway Route</span>
                </div>
            </div>

            <div class="settlement-list">
                <h3>Settlements Within 1 Hour</h3>
                <div id="settlementList"></div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let data = null;
        let trackData = null;         // Railway track geometry
        let networkData = null;       // Railway network (nodes/edges)
        let mappingData = null;       // Settlement to node mappings
        let map = null;
        let markers = {};
        let connectionLines = [];     // Railway route lines
        let radiusCircle = null;
        let isPlaying = false;
        let playInterval = null;

        // Initialize map
        function initMap() {
            map = L.map('map').setView([52.12, -106.67], 9);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
        }

        // Calculate distance between two lat/lon points in meters (Haversine)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Find intersection point of line segment with circle boundary
        function findCircleIntersection(pt1, pt2, centerLat, centerLon, radiusM) {
            const dist1 = haversineDistance(centerLat, centerLon, pt1[0], pt1[1]);
            let lo = 0, hi = 1;
            for (let iter = 0; iter < 20; iter++) {
                const mid = (lo + hi) / 2;
                const lat = pt1[0] + (pt2[0] - pt1[0]) * mid;
                const lon = pt1[1] + (pt2[1] - pt1[1]) * mid;
                const dist = haversineDistance(centerLat, centerLon, lat, lon);
                if (dist < radiusM) {
                    if (dist1 < radiusM) lo = mid;
                    else hi = mid;
                } else {
                    if (dist1 < radiusM) hi = mid;
                    else lo = mid;
                }
            }
            const t = (lo + hi) / 2;
            return [pt1[0] + (pt2[0] - pt1[0]) * t, pt1[1] + (pt2[1] - pt1[1]) * t];
        }

        // Clip a polyline to stay within a circle
        function clipPolylineToCircle(coords, centerLat, centerLon, radiusM) {
            if (!coords || coords.length < 2) return coords;
            const clipped = [];
            for (let i = 0; i < coords.length; i++) {
                const pt = coords[i];
                const dist = haversineDistance(centerLat, centerLon, pt[0], pt[1]);
                const isInside = dist <= radiusM;
                if (i === 0) {
                    if (isInside) clipped.push(pt);
                } else {
                    const prevPt = coords[i - 1];
                    const prevDist = haversineDistance(centerLat, centerLon, prevPt[0], prevPt[1]);
                    const prevInside = prevDist <= radiusM;
                    if (isInside && prevInside) {
                        clipped.push(pt);
                    } else if (isInside && !prevInside) {
                        clipped.push(findCircleIntersection(prevPt, pt, centerLat, centerLon, radiusM));
                        clipped.push(pt);
                    } else if (!isInside && prevInside) {
                        clipped.push(findCircleIntersection(prevPt, pt, centerLat, centerLon, radiusM));
                    }
                }
            }
            return clipped.length >= 2 ? clipped : null;
        }

        // Find shortest path between two nodes using Dijkstra
        function findPath(startNode, endNode) {
            if (!networkData || !networkData.adj) return null;
            if (startNode === endNode) return [startNode];
            const dist = {}, prev = {}, visited = new Set(), queue = [];
            dist[startNode] = 0;
            queue.push({node: startNode, dist: 0});
            while (queue.length > 0) {
                queue.sort((a, b) => a.dist - b.dist);
                const {node: current} = queue.shift();
                if (visited.has(current)) continue;
                visited.add(current);
                if (current === endNode) break;
                const neighbors = networkData.adj[current] || [];
                for (const {node: neighbor, weight} of neighbors) {
                    if (visited.has(neighbor)) continue;
                    const newDist = dist[current] + weight;
                    if (dist[neighbor] === undefined || newDist < dist[neighbor]) {
                        dist[neighbor] = newDist;
                        prev[neighbor] = current;
                        queue.push({node: neighbor, dist: newDist});
                    }
                }
            }
            if (prev[endNode] === undefined && startNode !== endNode) return null;
            const path = [];
            let current = endNode;
            while (current !== undefined) {
                path.unshift(current);
                current = prev[current];
            }
            return path;
        }

        // Get track geometry for a path
        function getPathGeometry(path) {
            if (!path || path.length < 2 || !trackData || !trackData.lookup) return null;
            const allCoords = [];
            for (let i = 0; i < path.length - 1; i++) {
                const key = `${path[i]}|${path[i+1]}`;
                const track = trackData.lookup[key];
                if (track && track.coordinates) {
                    let coords = track.coordinates.map(c => [c[1], c[0]]);
                    if (allCoords.length > 0) {
                        const lastPoint = allCoords[allCoords.length - 1];
                        const firstPoint = coords[0];
                        const lastPointReversed = coords[coords.length - 1];
                        const distToFirst = Math.abs(lastPoint[0] - firstPoint[0]) + Math.abs(lastPoint[1] - firstPoint[1]);
                        const distToLast = Math.abs(lastPoint[0] - lastPointReversed[0]) + Math.abs(lastPoint[1] - lastPointReversed[1]);
                        if (distToLast < distToFirst) coords = coords.reverse();
                    }
                    allCoords.push(...coords);
                }
            }
            return allCoords.length > 0 ? allCoords : null;
        }

        // Draw railway connection from Saskatoon to a settlement
        function drawRailwayConnection(settlementName, color, weight, opacity) {
            if (!mappingData || !mappingData.lookup) return null;
            const saskatoonMapping = mappingData.lookup['Saskatoon'];
            const toMapping = mappingData.lookup[settlementName];
            if (!saskatoonMapping || !toMapping) return null;
            const path = findPath(saskatoonMapping.snap_node, toMapping.snap_node);
            if (!path) return null;
            const coords = getPathGeometry(path);
            if (!coords || coords.length < 2) return null;
            return L.polyline(coords, { color, weight, opacity });
        }

        // Load data and initialize
        async function loadData() {
            const response = await fetch('data/one_hour_corridor.json');
            data = await response.json();

            // Load railway track geometry
            try {
                const trackResponse = await fetch('data/railway_tracks.json');
                if (trackResponse.ok) {
                    trackData = await trackResponse.json();
                    trackData.lookup = {};
                    trackData.tracks.forEach(t => {
                        trackData.lookup[`${t.source}|${t.target}`] = t;
                        trackData.lookup[`${t.target}|${t.source}`] = t;
                    });
                }
            } catch (e) { console.warn('Could not load track geometry:', e); }

            // Load network graph for pathfinding
            try {
                const networkResponse = await fetch('data/railway_network.json');
                if (networkResponse.ok) {
                    networkData = await networkResponse.json();
                    networkData.adj = {};
                    networkData.edges.forEach(e => {
                        if (!networkData.adj[e.source]) networkData.adj[e.source] = [];
                        if (!networkData.adj[e.target]) networkData.adj[e.target] = [];
                        networkData.adj[e.source].push({node: e.target, weight: e.length_m});
                        networkData.adj[e.target].push({node: e.source, weight: e.length_m});
                    });
                }
            } catch (e) { console.warn('Could not load network:', e); }

            // Load settlement to node mappings
            try {
                const mappingResponse = await fetch('data/settlement_network_mapping.json');
                if (mappingResponse.ok) {
                    mappingData = await mappingResponse.json();
                    mappingData.lookup = {};
                    mappingData.mappings.forEach(m => {
                        mappingData.lookup[m.settlement] = m;
                    });
                }
            } catch (e) { console.warn('Could not load mappings:', e); }

            // Add Saskatoon marker
            const saskatoonIcon = L.divIcon({
                className: 'custom-marker',
                html: '<div style="background:#e94560; width:20px; height:20px; border-radius:50%; border:3px solid white;"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });

            L.marker([data.saskatoon.lat, data.saskatoon.lon], {icon: saskatoonIcon})
                .addTo(map)
                .bindPopup('<b>Saskatoon</b><br>First railway: 1890 (QLSRSC)');

            // Add 40km radius circle
            radiusCircle = L.circle([data.saskatoon.lat, data.saskatoon.lon], {
                radius: 40000,
                color: '#e94560',
                fillColor: '#e94560',
                fillOpacity: 0.1,
                dashArray: '10, 10',
                weight: 2
            }).addTo(map);

            // Add settlement markers
            data.settlements.forEach(s => {
                const marker = L.circleMarker([s.lat, s.lon], {
                    radius: 8,
                    fillColor: '#666',
                    color: '#fff',
                    weight: 1,
                    opacity: 0.5,
                    fillOpacity: 0.5
                }).addTo(map);

                const railDist = s.railway_distance_km;
                const distanceDisplay = railDist != null && railDist > 0
                    ? `Direct: ${s.distance_km} km | By rail: ${railDist} km`
                    : `Distance: ${s.distance_km} km`;

                marker.bindPopup(`
                    <b>${s.name}</b><br>
                    ${distanceDisplay}<br>
                    Railway: ${s.first_railway || 'Unknown'}<br>
                    Railway Arrives: ${s.railway_arrives || 'Unknown'}<br>
                    Connected to Saskatoon: ${s.connected_to_saskatoon || 'Unknown'}
                `);

                markers[s.name] = {marker, data: s};
            });

            document.getElementById('totalCount').textContent = data.settlements.length;
            updateYear(1890);
        }

        // Update visualization for selected year
        function updateYear(year) {
            document.getElementById('yearDisplay').textContent = year;
            document.getElementById('yearSlider').value = year;

            // Clear existing connection lines
            connectionLines.forEach(line => map.removeLayer(line));
            connectionLines = [];

            let connectedCount = 0;
            let listHTML = '';

            const connectedSettlements = [];

            data.settlements.forEach(s => {
                const isConnected = s.connected_to_saskatoon && s.connected_to_saskatoon <= year;
                const m = markers[s.name];

                if (isConnected) {
                    connectedCount++;
                    connectedSettlements.push(s);
                    m.marker.setStyle({
                        fillColor: '#4ecca3',
                        opacity: 1,
                        fillOpacity: 0.9
                    });

                    // Draw railway connection line (clipped to 40km)
                    let line = drawRailwayConnection(s.name, '#4ecca3', 3, 0.7);
                    if (!line) {
                        // Fallback to straight line if railway path not found
                        line = L.polyline(
                            [[data.saskatoon.lat, data.saskatoon.lon], [s.lat, s.lon]],
                            { color: '#4ecca3', weight: 2, opacity: 0.5, dashArray: '5, 5' }
                        );
                    }
                    line.addTo(map);
                    connectionLines.push(line);
                } else {
                    m.marker.setStyle({
                        fillColor: '#666',
                        opacity: 0.5,
                        fillOpacity: 0.5
                    });
                }
            });

            // Sort by distance
            connectedSettlements.sort((a, b) => a.distance_km - b.distance_km);

            connectedSettlements.forEach(s => {
                const railDist = s.railway_distance_km;
                const distStr = railDist != null && railDist > 0
                    ? `${s.distance_km} km direct / ${railDist} km by rail`
                    : `${s.distance_km} km`;
                listHTML += `
                    <div class="settlement-item">
                        <div class="name">${s.name}</div>
                        <div class="details">
                            ${distStr} | ${s.first_railway} (${s.railway_arrives})
                        </div>
                    </div>
                `;
            });

            document.getElementById('connectedCount').textContent = connectedCount;
            document.getElementById('settlementList').innerHTML = listHTML || '<p style="color:#666;">No settlements connected yet</p>';
        }

        // Play animation
        function togglePlay() {
            if (isPlaying) {
                clearInterval(playInterval);
                document.getElementById('playBtn').textContent = 'Play';
                isPlaying = false;
            } else {
                isPlaying = true;
                document.getElementById('playBtn').textContent = 'Pause';
                let year = parseInt(document.getElementById('yearSlider').value);

                playInterval = setInterval(() => {
                    year += 5;
                    if (year > 1920) {
                        clearInterval(playInterval);
                        document.getElementById('playBtn').textContent = 'Play';
                        isPlaying = false;
                        return;
                    }
                    updateYear(year);
                }, 1500);
            }
        }

        // Reset to 1890
        function reset() {
            if (isPlaying) {
                togglePlay();
            }
            updateYear(1890);
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadData();

            document.getElementById('yearSlider').addEventListener('input', (e) => {
                updateYear(parseInt(e.target.value));
            });

            document.getElementById('playBtn').addEventListener('click', togglePlay);
            document.getElementById('resetBtn').addEventListener('click', reset);
        });
    </script>
</body>
</html>
