<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One-Hour Railway Corridor from Saskatoon</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #eee;
        }
        .header {
            background: #1a1a1e;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #0b6a41;
        }
        .header h1 {
            color: #ffffff;
            margin-bottom: 10px;
        }
        .header p {
            color: #9A9B9D;
            max-width: 800px;
            margin: 0 auto;
        }
        .nav {
            background: #252528;
            padding: 10px;
            text-align: center;
            position: relative;
        }
        .nav-dropdown {
            position: relative;
            display: inline-block;
        }
        .nav-btn {
            color: #f1c730;
            background: transparent;
            border: 1px solid #f1c730;
            padding: 8px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .nav-btn:hover {
            background: #f1c730;
            color: #000;
        }
        .nav-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #252528;
            border: 1px solid #f1c730;
            border-radius: 5px;
            padding: 10px 0;
            min-width: 200px;
            z-index: 1000;
            margin-top: 5px;
        }
        .nav-menu.show {
            display: block;
        }
        .nav-menu a {
            display: block;
            color: #f1c730;
            text-decoration: none;
            padding: 8px 20px;
            transition: all 0.2s;
        }
        .nav-menu a:hover {
            background: #0b6a41;
            color: #fff;
        }
        .nav-menu a.current {
            color: #0b6a41;
            font-weight: bold;
        }
        .container {
            display: flex;
            height: calc(100vh - 160px);
        }
        #map {
            flex: 1;
            height: 100%;
        }
        .sidebar {
            width: 320px;
            background: #1a1a1e;
            padding: 20px;
            overflow-y: auto;
        }
        .controls {
            margin-bottom: 10px;
        }
        .year-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .year-row label {
            color: #f1c730;
            font-size: 13px;
            font-weight: bold;
        }
        .year-row input[type="range"] {
            flex: 1;
            margin: 0;
        }
        .year-display {
            font-size: 16px;
            font-weight: bold;
            color: #f1c730;
            min-width: 35px;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #4D4E53;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: transparent;
            border-radius: 3px;
        }
        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #4D4E53;
            border-radius: 3px;
        }
        input[type="range"]::-moz-range-progress {
            height: 6px;
            background: #f1c730;
            border-radius: 3px 0 0 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            margin-top: -5px;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }
        .stats {
            background: #252528;
            padding: 10px 12px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .stats h3 {
            color: #f1c730;
            margin-bottom: 8px;
            border-bottom: 1px solid #0b6a41;
            padding-bottom: 5px;
            font-size: 13px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #000000;
            font-size: 12px;
        }
        .settlement-list {
            margin-top: 10px;
        }
        .settlement-list h3 {
            color: #f1c730;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .settlement-item {
            background: #252528;
            padding: 8px;
            margin: 4px 0;
            border-radius: 3px;
            border-left: 3px solid #0b6a41;
        }
        .settlement-item .name {
            font-weight: bold;
            font-size: 13px;
        }
        .settlement-item .details {
            font-size: 11px;
            color: #aaa;
            margin-top: 3px;
        }
        .legend {
            background: #252528;
            padding: 10px 12px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .legend h3 {
            color: #f1c730;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 12px;
        }
        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .play-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .play-controls button {
            background: #0b6a41;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }
        .play-controls button:hover {
            background: #0d8550;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>One-Hour Railway Corridor from Saskatoon</h1>
        <p>Explore which settlements could be reached from Saskatoon within one hour by train<br>(40 km at 40 km/h average speed) as the railway network expanded from 1890 to 1920.</p>
    </div>
    <div class="nav">
        <div class="nav-dropdown">
            <button class="nav-btn" id="navBtn">Other Visualizations â–¼</button>
            <div class="nav-menu" id="navMenu">
                <a href="index.html">Home</a>
                <a href="one_hour_map.html" class="current">Saskatoon Corridor</a>
                <a href="settlement_explorer.html">Settlement Explorer</a>
                <a href="railway_timeline.html">Railway Timeline</a>
                <a href="network_graph.html">Network Graph</a>
                <a href="isochrone.html">Travel Comparison</a>
                <a href="journey_times.html">Journey Times</a>
                <a href="travel_race.html">Time Simulation</a>
                <a href="transport_eras.html">Transport Eras</a>
                <a href="railway_temporal_network.html">Temporal Network</a>
            </div>
        </div>
    </div>
    <div class="container">
        <div id="map"></div>
        <div class="sidebar">
            <div class="controls">
                <div class="year-row">
                    <label>Year:</label>
                    <span class="year-display" id="yearDisplay">1890</span>
                    <input type="range" id="yearSlider" min="1890" max="1920" step="5" value="1890">
                </div>
                <div class="play-controls">
                    <button id="playBtn">Play</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>

            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-item">
                    <span>Connected Settlements:</span>
                    <span id="connectedCount">0</span>
                </div>
                <div class="stat-item">
                    <span>Total in Range:</span>
                    <span id="totalCount">0</span>
                </div>
            </div>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #0b6a41;"></div>
                    <span>Saskatoon</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #f1c730;"></div>
                    <span>Connected Settlement</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #9A9B9D; opacity: 0.5;"></div>
                    <span>Not Yet Connected</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: transparent; border: 2px dashed #0b6a41;"></div>
                    <span>40 km Radius (1 hour)</span>
                </div>
                <div class="legend-item">
                    <div style="width: 20px; height: 3px; background: #f1c730; margin-right: 10px;"></div>
                    <span>Railway Route</span>
                </div>
            </div>

            <div class="settlement-list">
                <h3>Settlements Within 1 Hour</h3>
                <div id="settlementList"></div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Nav dropdown toggle
        document.getElementById('navBtn').addEventListener('click', function(e) {
            e.stopPropagation();
            document.getElementById('navMenu').classList.toggle('show');
        });
        document.addEventListener('click', function() {
            document.getElementById('navMenu').classList.remove('show');
        });

        let data = null;
        let trackData = null;         // Railway track geometry
        let networkData = null;       // Railway network (nodes/edges)
        let mappingData = null;       // Settlement to node mappings
        let map = null;
        let markers = {};
        let connectionLines = [];     // Railway route lines
        let radiusCircle = null;
        let isPlaying = false;
        let playInterval = null;

        // Initialize map
        function initMap() {
            map = L.map('map').setView([52.12, -106.67], 9);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
        }

        // Calculate distance between two lat/lon points in meters (Haversine)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Find intersection point of line segment with circle boundary
        function findCircleIntersection(pt1, pt2, centerLat, centerLon, radiusM) {
            const dist1 = haversineDistance(centerLat, centerLon, pt1[0], pt1[1]);
            let lo = 0, hi = 1;
            for (let iter = 0; iter < 20; iter++) {
                const mid = (lo + hi) / 2;
                const lat = pt1[0] + (pt2[0] - pt1[0]) * mid;
                const lon = pt1[1] + (pt2[1] - pt1[1]) * mid;
                const dist = haversineDistance(centerLat, centerLon, lat, lon);
                if (dist < radiusM) {
                    if (dist1 < radiusM) lo = mid;
                    else hi = mid;
                } else {
                    if (dist1 < radiusM) hi = mid;
                    else lo = mid;
                }
            }
            const t = (lo + hi) / 2;
            return [pt1[0] + (pt2[0] - pt1[0]) * t, pt1[1] + (pt2[1] - pt1[1]) * t];
        }

        // Clip a polyline to stay within a circle
        function clipPolylineToCircle(coords, centerLat, centerLon, radiusM) {
            if (!coords || coords.length < 2) return coords;
            const clipped = [];
            for (let i = 0; i < coords.length; i++) {
                const pt = coords[i];
                const dist = haversineDistance(centerLat, centerLon, pt[0], pt[1]);
                const isInside = dist <= radiusM;
                if (i === 0) {
                    if (isInside) clipped.push(pt);
                } else {
                    const prevPt = coords[i - 1];
                    const prevDist = haversineDistance(centerLat, centerLon, prevPt[0], prevPt[1]);
                    const prevInside = prevDist <= radiusM;
                    if (isInside && prevInside) {
                        clipped.push(pt);
                    } else if (isInside && !prevInside) {
                        clipped.push(findCircleIntersection(prevPt, pt, centerLat, centerLon, radiusM));
                        clipped.push(pt);
                    } else if (!isInside && prevInside) {
                        clipped.push(findCircleIntersection(prevPt, pt, centerLat, centerLon, radiusM));
                    }
                }
            }
            return clipped.length >= 2 ? clipped : null;
        }

        // Find shortest path between two nodes using Dijkstra
        function findPath(startNode, endNode) {
            if (!networkData || !networkData.adj) return null;
            if (startNode === endNode) return [startNode];
            const dist = {}, prev = {}, visited = new Set(), queue = [];
            dist[startNode] = 0;
            queue.push({node: startNode, dist: 0});
            while (queue.length > 0) {
                queue.sort((a, b) => a.dist - b.dist);
                const {node: current} = queue.shift();
                if (visited.has(current)) continue;
                visited.add(current);
                if (current === endNode) break;
                const neighbors = networkData.adj[current] || [];
                for (const {node: neighbor, weight} of neighbors) {
                    if (visited.has(neighbor)) continue;
                    const newDist = dist[current] + weight;
                    if (dist[neighbor] === undefined || newDist < dist[neighbor]) {
                        dist[neighbor] = newDist;
                        prev[neighbor] = current;
                        queue.push({node: neighbor, dist: newDist});
                    }
                }
            }
            if (prev[endNode] === undefined && startNode !== endNode) return null;
            const path = [];
            let current = endNode;
            while (current !== undefined) {
                path.unshift(current);
                current = prev[current];
            }
            return path;
        }

        // Get track geometry for a path
        function getPathGeometry(path) {
            if (!path || path.length < 2 || !trackData || !trackData.lookup) return null;
            const allCoords = [];
            for (let i = 0; i < path.length - 1; i++) {
                const key = `${path[i]}|${path[i+1]}`;
                const track = trackData.lookup[key];
                if (track && track.coordinates) {
                    let coords = track.coordinates.map(c => [c[1], c[0]]);
                    if (allCoords.length > 0) {
                        const lastPoint = allCoords[allCoords.length - 1];
                        const firstPoint = coords[0];
                        const lastPointReversed = coords[coords.length - 1];
                        const distToFirst = Math.abs(lastPoint[0] - firstPoint[0]) + Math.abs(lastPoint[1] - firstPoint[1]);
                        const distToLast = Math.abs(lastPoint[0] - lastPointReversed[0]) + Math.abs(lastPoint[1] - lastPointReversed[1]);
                        if (distToLast < distToFirst) coords = coords.reverse();
                    }
                    allCoords.push(...coords);
                }
            }
            return allCoords.length > 0 ? allCoords : null;
        }

        // Find the index of the point on a path closest to a given location
        function findClosestPointIndex(coords, targetLat, targetLon) {
            let minDist = Infinity;
            let minIndex = 0;
            for (let i = 0; i < coords.length; i++) {
                const dist = haversineDistance(coords[i][0], coords[i][1], targetLat, targetLon);
                if (dist < minDist) {
                    minDist = dist;
                    minIndex = i;
                }
            }
            return minIndex;
        }

        // Trim path to start and end at settlement locations
        function trimPathToSettlements(coords, fromLat, fromLon, toLat, toLon) {
            if (!coords || coords.length < 2) return coords;
            const startIndex = findClosestPointIndex(coords, fromLat, fromLon);
            const endIndex = findClosestPointIndex(coords, toLat, toLon);
            let trimmedCoords;
            if (startIndex <= endIndex) {
                trimmedCoords = coords.slice(startIndex, endIndex + 1);
            } else {
                trimmedCoords = coords.slice(endIndex, startIndex + 1).reverse();
            }
            if (trimmedCoords.length >= 2) {
                trimmedCoords[0] = [fromLat, fromLon];
                trimmedCoords[trimmedCoords.length - 1] = [toLat, toLon];
            }
            return trimmedCoords;
        }

        // Extend path geometry to include partial edge when settlement is snapped mid-edge
        function extendPathToEdge(coords, mapping, settlementLat, settlementLon, atEnd) {
            if (!mapping.snap_nodes || mapping.snap_nodes.length !== 2) return coords;

            const [node1, node2] = mapping.snap_nodes;
            const edgeKey1 = `${node1}|${node2}`;
            const edgeKey2 = `${node2}|${node1}`;

            const track = trackData.lookup[edgeKey1] || trackData.lookup[edgeKey2];
            if (!track || !track.coordinates) return coords;

            let trackCoords = track.coordinates.map(c => [c[1], c[0]]);

            let minDist = Infinity;
            let closestIdx = 0;
            for (let i = 0; i < trackCoords.length; i++) {
                const dist = haversineDistance(trackCoords[i][0], trackCoords[i][1], settlementLat, settlementLon);
                if (dist < minDist) {
                    minDist = dist;
                    closestIdx = i;
                }
            }

            const currentEndpoint = atEnd ? coords[coords.length - 1] : coords[0];
            const currentDist = haversineDistance(currentEndpoint[0], currentEndpoint[1], settlementLat, settlementLon);

            if (minDist >= currentDist) return coords;

            const pathEndpoint = atEnd ? coords[coords.length - 1] : coords[0];
            const distToTrackStart = Math.abs(pathEndpoint[0] - trackCoords[0][0]) + Math.abs(pathEndpoint[1] - trackCoords[0][1]);
            const distToTrackEnd = Math.abs(pathEndpoint[0] - trackCoords[trackCoords.length-1][0]) + Math.abs(pathEndpoint[1] - trackCoords[trackCoords.length-1][1]);

            let extensionCoords;
            if (distToTrackStart < distToTrackEnd) {
                extensionCoords = trackCoords.slice(0, closestIdx + 1);
            } else {
                extensionCoords = trackCoords.slice(closestIdx).reverse();
            }

            if (atEnd) {
                return [...coords, ...extensionCoords.slice(1)];
            } else {
                return [...extensionCoords.slice(0, -1), ...coords];
            }
        }

        // Check if two arrays of node IDs represent the same edge
        function isSameEdge(nodes1, nodes2) {
            if (!nodes1 || !nodes2 || nodes1.length !== 2 || nodes2.length !== 2) return false;
            return (nodes1[0] === nodes2[0] && nodes1[1] === nodes2[1]) ||
                   (nodes1[0] === nodes2[1] && nodes1[1] === nodes2[0]);
        }

        // Get geometry for two settlements on the same edge
        function getSameEdgeGeometry(fromMapping, toMapping, fromLat, fromLon, toLat, toLon) {
            if (!fromMapping.snap_nodes || !toMapping.snap_nodes) return null;
            if (fromMapping.snap_nodes.length !== 2 || toMapping.snap_nodes.length !== 2) return null;
            if (!isSameEdge(fromMapping.snap_nodes, toMapping.snap_nodes)) return null;

            const [node1, node2] = fromMapping.snap_nodes;
            const edgeKey = `${node1}|${node2}`;
            const track = trackData.lookup[edgeKey] || trackData.lookup[`${node2}|${node1}`];
            if (!track || !track.coordinates) return null;

            const trackCoords = track.coordinates.map(c => [c[1], c[0]]);
            let fromIdx = 0, toIdx = 0;
            let fromMinDist = Infinity, toMinDist = Infinity;

            for (let i = 0; i < trackCoords.length; i++) {
                const fromDist = haversineDistance(trackCoords[i][0], trackCoords[i][1], fromLat, fromLon);
                const toDist = haversineDistance(trackCoords[i][0], trackCoords[i][1], toLat, toLon);
                if (fromDist < fromMinDist) { fromMinDist = fromDist; fromIdx = i; }
                if (toDist < toMinDist) { toMinDist = toDist; toIdx = i; }
            }

            let coords;
            if (fromIdx <= toIdx) {
                coords = trackCoords.slice(fromIdx, toIdx + 1);
            } else {
                coords = trackCoords.slice(toIdx, fromIdx + 1).reverse();
            }

            // If both settlements project to the same point (sparse track geometry),
            // create a simple 2-point path through the closest track point
            if (coords.length < 2) {
                const trackPoint = trackCoords[fromIdx];
                return [[fromLat, fromLon], trackPoint, [toLat, toLon]];
            }

            return coords;
        }

        // Get geometry for settlements on different edges meeting at a shared node
        function getSharedNodeGeometry(fromMapping, toMapping, fromLat, fromLon, toLat, toLon) {
            if (!fromMapping.snap_nodes || !toMapping.snap_nodes) return null;
            if (fromMapping.snap_nodes.length !== 2 || toMapping.snap_nodes.length !== 2) return null;
            if (fromMapping.snap_node !== toMapping.snap_node) return null;
            if (isSameEdge(fromMapping.snap_nodes, toMapping.snap_nodes)) return null;

            const [fromNode1, fromNode2] = fromMapping.snap_nodes;
            const fromTrack = trackData.lookup[`${fromNode1}|${fromNode2}`] || trackData.lookup[`${fromNode2}|${fromNode1}`];
            const [toNode1, toNode2] = toMapping.snap_nodes;
            const toTrack = trackData.lookup[`${toNode1}|${toNode2}`] || trackData.lookup[`${toNode2}|${toNode1}`];

            if (!fromTrack || !toTrack || !fromTrack.coordinates || !toTrack.coordinates) return null;

            const fromCoords = fromTrack.coordinates.map(c => [c[1], c[0]]);
            const toCoords = toTrack.coordinates.map(c => [c[1], c[0]]);

            let fromIdx = 0, fromMinDist = Infinity;
            for (let i = 0; i < fromCoords.length; i++) {
                const dist = haversineDistance(fromCoords[i][0], fromCoords[i][1], fromLat, fromLon);
                if (dist < fromMinDist) { fromMinDist = dist; fromIdx = i; }
            }

            let toIdx = 0, toMinDist = Infinity;
            for (let i = 0; i < toCoords.length; i++) {
                const dist = haversineDistance(toCoords[i][0], toCoords[i][1], toLat, toLon);
                if (dist < toMinDist) { toMinDist = dist; toIdx = i; }
            }

            // Determine which end of each track is the shared node by checking actual coordinates
            const sharedNode = fromMapping.snap_node;
            const sharedNodeData = networkData.nodes.find(n => n.id === sharedNode);
            if (!sharedNodeData) return null;

            const fromStartDist = Math.abs(fromCoords[0][0] - sharedNodeData.lat) + Math.abs(fromCoords[0][1] - sharedNodeData.lon);
            const fromEndDist = Math.abs(fromCoords[fromCoords.length-1][0] - sharedNodeData.lat) + Math.abs(fromCoords[fromCoords.length-1][1] - sharedNodeData.lon);
            const fromTrackStartIsShared = fromStartDist < fromEndDist;

            const toStartDist = Math.abs(toCoords[0][0] - sharedNodeData.lat) + Math.abs(toCoords[0][1] - sharedNodeData.lon);
            const toEndDist = Math.abs(toCoords[toCoords.length-1][0] - sharedNodeData.lat) + Math.abs(toCoords[toCoords.length-1][1] - sharedNodeData.lon);
            const toTrackStartIsShared = toStartDist < toEndDist;

            let fromPortion = fromTrackStartIsShared
                ? fromCoords.slice(0, fromIdx + 1).reverse()
                : fromCoords.slice(fromIdx);

            let toPortion = toTrackStartIsShared
                ? toCoords.slice(0, toIdx + 1)
                : toCoords.slice(toIdx).reverse();

            const combined = [...fromPortion, ...toPortion.slice(1)];
            return combined.length >= 2 ? combined : null;
        }

        // Get geometry when one or both settlements are snapped to a node (not an edge)
        function getNodeOnlyGeometry(fromMapping, toMapping, fromLat, fromLon, toLat, toLon) {
            if (fromMapping.snap_node !== toMapping.snap_node) return null;

            const fromIsNodeOnly = !fromMapping.snap_nodes || fromMapping.snap_nodes.length === 1;
            const toIsNodeOnly = !toMapping.snap_nodes || toMapping.snap_nodes.length === 1;
            if (!fromIsNodeOnly && !toIsNodeOnly) return null;

            const sharedNode = fromMapping.snap_node;
            const sharedNodeData = networkData.nodes.find(n => n.id === sharedNode);
            if (!sharedNodeData) return null;

            if (fromIsNodeOnly && toIsNodeOnly) {
                return [[fromLat, fromLon], [sharedNodeData.lat, sharedNodeData.lon], [toLat, toLon]];
            }

            const edgeMapping = fromIsNodeOnly ? toMapping : fromMapping;
            const edgeLat = fromIsNodeOnly ? toLat : fromLat;
            const edgeLon = fromIsNodeOnly ? toLon : fromLon;
            const nodeLat = fromIsNodeOnly ? fromLat : toLat;
            const nodeLon = fromIsNodeOnly ? fromLon : toLon;

            const [node1, node2] = edgeMapping.snap_nodes;
            const track = trackData.lookup[`${node1}|${node2}`] || trackData.lookup[`${node2}|${node1}`];

            if (!track || !track.coordinates) {
                return [[fromLat, fromLon], [sharedNodeData.lat, sharedNodeData.lon], [toLat, toLon]];
            }

            const trackCoords = track.coordinates.map(c => [c[1], c[0]]);
            const startDist = Math.abs(trackCoords[0][0] - sharedNodeData.lat) + Math.abs(trackCoords[0][1] - sharedNodeData.lon);
            const endDist = Math.abs(trackCoords[trackCoords.length-1][0] - sharedNodeData.lat) + Math.abs(trackCoords[trackCoords.length-1][1] - sharedNodeData.lon);
            const nodeAtStart = startDist < endDist;

            let closestIdx = 0, minDist = Infinity;
            for (let i = 0; i < trackCoords.length; i++) {
                const dist = haversineDistance(trackCoords[i][0], trackCoords[i][1], edgeLat, edgeLon);
                if (dist < minDist) { minDist = dist; closestIdx = i; }
            }

            let portion = nodeAtStart ? trackCoords.slice(0, closestIdx + 1) : trackCoords.slice(closestIdx).reverse();

            if (fromIsNodeOnly) {
                return [[nodeLat, nodeLon], ...portion.slice(1)];
            } else {
                return [...portion.slice(0, -1).reverse(), [nodeLat, nodeLon]];
            }
        }

        // Draw railway connection from Saskatoon to a settlement
        function drawRailwayConnection(settlementName, color, weight, opacity) {
            if (!mappingData || !mappingData.lookup) return null;
            const saskatoonMapping = mappingData.lookup['Saskatoon'];
            const toMapping = mappingData.lookup[settlementName];
            if (!saskatoonMapping || !toMapping) return null;

            const settlement = data.settlements.find(s => s.name === settlementName);
            if (!settlement) return null;

            const fromNode = saskatoonMapping.snap_node;
            const toNode = toMapping.snap_node;

            let coords = null;

            // Case 1: Both settlements on the same snap_node
            if (fromNode === toNode) {
                coords = getSameEdgeGeometry(saskatoonMapping, toMapping, data.saskatoon.lat, data.saskatoon.lon, settlement.lat, settlement.lon);
                if (!coords) {
                    coords = getSharedNodeGeometry(saskatoonMapping, toMapping, data.saskatoon.lat, data.saskatoon.lon, settlement.lat, settlement.lon);
                }
                if (!coords) {
                    coords = getNodeOnlyGeometry(saskatoonMapping, toMapping, data.saskatoon.lat, data.saskatoon.lon, settlement.lat, settlement.lon);
                }
            }

            // Case 2: Different nodes - use pathfinding
            if (!coords) {
                const path = findPath(fromNode, toNode);
                if (!path) return null;

                coords = getPathGeometry(path);
                if (coords && coords.length >= 2) {
                    coords = extendPathToEdge(coords, saskatoonMapping, data.saskatoon.lat, data.saskatoon.lon, false);
                    coords = extendPathToEdge(coords, toMapping, settlement.lat, settlement.lon, true);
                }
            }

            if (!coords || coords.length < 2) return null;

            coords = trimPathToSettlements(coords, data.saskatoon.lat, data.saskatoon.lon, settlement.lat, settlement.lon);
            if (!coords || coords.length < 2) return null;

            return L.polyline(coords, { color, weight, opacity });
        }

        // Load data and initialize
        async function loadData() {
            const response = await fetch('data/one_hour_corridor.json');
            data = await response.json();

            // Load railway track geometry
            try {
                const trackResponse = await fetch('data/railway_tracks.json');
                if (trackResponse.ok) {
                    trackData = await trackResponse.json();
                    trackData.lookup = {};
                    trackData.tracks.forEach(t => {
                        trackData.lookup[`${t.source}|${t.target}`] = t;
                        trackData.lookup[`${t.target}|${t.source}`] = t;
                    });
                }
            } catch (e) { console.warn('Could not load track geometry:', e); }

            // Load network graph for pathfinding
            try {
                const networkResponse = await fetch('data/railway_network.json');
                if (networkResponse.ok) {
                    networkData = await networkResponse.json();
                    networkData.adj = {};
                    networkData.edges.forEach(e => {
                        if (!networkData.adj[e.source]) networkData.adj[e.source] = [];
                        if (!networkData.adj[e.target]) networkData.adj[e.target] = [];
                        networkData.adj[e.source].push({node: e.target, weight: e.length_m});
                        networkData.adj[e.target].push({node: e.source, weight: e.length_m});
                    });
                }
            } catch (e) { console.warn('Could not load network:', e); }

            // Load settlement to node mappings
            try {
                const mappingResponse = await fetch('data/settlement_network_mapping.json');
                if (mappingResponse.ok) {
                    mappingData = await mappingResponse.json();
                    mappingData.lookup = {};
                    mappingData.mappings.forEach(m => {
                        mappingData.lookup[m.settlement] = m;
                    });
                }
            } catch (e) { console.warn('Could not load mappings:', e); }

            // Add Saskatoon marker
            const saskatoonIcon = L.divIcon({
                className: 'custom-marker',
                html: '<div style="background:#0b6a41; width:20px; height:20px; border-radius:50%; border:3px solid white;"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });

            L.marker([data.saskatoon.lat, data.saskatoon.lon], {icon: saskatoonIcon})
                .addTo(map)
                .bindPopup('<b>Saskatoon</b><br>First railway: 1890 (QLSRSC)');

            // Add 40km radius circle
            radiusCircle = L.circle([data.saskatoon.lat, data.saskatoon.lon], {
                radius: 40000,
                color: '#0b6a41',
                fillColor: '#0b6a41',
                fillOpacity: 0.1,
                dashArray: '10, 10',
                weight: 2
            }).addTo(map);

            // Add settlement markers
            data.settlements.forEach(s => {
                const marker = L.circleMarker([s.lat, s.lon], {
                    radius: 8,
                    fillColor: '#9A9B9D',
                    color: '#fff',
                    weight: 1,
                    opacity: 0.5,
                    fillOpacity: 0.5
                }).addTo(map);

                const railDist = s.railway_distance_km;
                const distanceDisplay = railDist != null && railDist > 0
                    ? `Direct: ${s.distance_km} km | By rail: ${railDist} km`
                    : `Distance: ${s.distance_km} km`;

                marker.bindPopup(`
                    <b>${s.name}</b><br>
                    ${distanceDisplay}<br>
                    Railway: ${s.first_railway || 'Unknown'}<br>
                    Railway Arrives: ${s.railway_arrives || 'Unknown'}<br>
                    Connected to Saskatoon: ${s.connected_to_saskatoon || 'Unknown'}
                `);

                markers[s.name] = {marker, data: s};
            });

            document.getElementById('totalCount').textContent = data.settlements.length;
            updateYear(1890);
        }

        // Update slider track progress
        function updateSliderTrack(slider) {
            const min = parseInt(slider.min);
            const max = parseInt(slider.max);
            const val = parseInt(slider.value);
            const percent = ((val - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #f1c730 0%, #f1c730 ${percent}%, #4D4E53 ${percent}%, #4D4E53 100%)`;
        }

        // Update visualization for selected year
        function updateYear(year) {
            document.getElementById('yearDisplay').textContent = year;
            const slider = document.getElementById('yearSlider');
            slider.value = year;
            updateSliderTrack(slider);

            // Clear existing connection lines
            connectionLines.forEach(line => map.removeLayer(line));
            connectionLines = [];

            let connectedCount = 0;
            let listHTML = '';

            const connectedSettlements = [];

            data.settlements.forEach(s => {
                const isConnected = s.connected_to_saskatoon && s.connected_to_saskatoon <= year;
                const m = markers[s.name];

                if (isConnected) {
                    connectedCount++;
                    connectedSettlements.push(s);
                    m.marker.setStyle({
                        fillColor: '#f1c730',
                        opacity: 1,
                        fillOpacity: 0.9
                    });

                    // Draw railway connection line (clipped to 40km)
                    let line = drawRailwayConnection(s.name, '#f1c730', 3, 0.7);
                    if (!line) {
                        // Fallback to straight line if railway path not found
                        line = L.polyline(
                            [[data.saskatoon.lat, data.saskatoon.lon], [s.lat, s.lon]],
                            { color: '#f1c730', weight: 2, opacity: 0.5, dashArray: '5, 5' }
                        );
                    }
                    line.addTo(map);
                    connectionLines.push(line);
                } else {
                    m.marker.setStyle({
                        fillColor: '#9A9B9D',
                        opacity: 0.5,
                        fillOpacity: 0.5
                    });
                }
            });

            // Sort by distance
            connectedSettlements.sort((a, b) => a.distance_km - b.distance_km);

            connectedSettlements.forEach(s => {
                const railDist = s.railway_distance_km;
                const distStr = railDist != null && railDist > 0
                    ? `${s.distance_km} km direct / ${railDist} km by rail`
                    : `${s.distance_km} km`;
                listHTML += `
                    <div class="settlement-item">
                        <div class="name">${s.name}</div>
                        <div class="details">
                            ${distStr} | ${s.first_railway} (${s.railway_arrives})
                        </div>
                    </div>
                `;
            });

            document.getElementById('connectedCount').textContent = connectedCount;
            document.getElementById('settlementList').innerHTML = listHTML || '<p style="color:#9A9B9D;">No settlements connected yet</p>';
        }

        // Play animation
        function togglePlay() {
            if (isPlaying) {
                clearInterval(playInterval);
                document.getElementById('playBtn').textContent = 'Play';
                isPlaying = false;
            } else {
                isPlaying = true;
                document.getElementById('playBtn').textContent = 'Pause';
                let year = parseInt(document.getElementById('yearSlider').value);

                playInterval = setInterval(() => {
                    year += 5;
                    if (year > 1920) {
                        clearInterval(playInterval);
                        document.getElementById('playBtn').textContent = 'Play';
                        isPlaying = false;
                        return;
                    }
                    updateYear(year);
                }, 1500);
            }
        }

        // Reset to 1890
        function reset() {
            if (isPlaying) {
                togglePlay();
            }
            updateYear(1890);
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadData();

            document.getElementById('yearSlider').addEventListener('input', (e) => {
                updateYear(parseInt(e.target.value));
            });

            document.getElementById('playBtn').addEventListener('click', togglePlay);
            document.getElementById('resetBtn').addEventListener('click', reset);
        });
    </script>
</body>
</html>
