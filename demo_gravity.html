<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo: Gravitational Pull Animation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        .header {
            background: #16213e;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #e94560;
        }
        .header h1 { color: #e94560; margin-bottom: 10px; }
        .header p { color: #aaa; max-width: 800px; margin: 0 auto; }
        .container {
            display: flex;
            height: calc(100vh - 120px);
        }
        #canvas {
            flex: 1;
            min-width: 0;
            background: #1a1a2e;
        }
        .sidebar {
            width: 320px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
        }
        .control-group {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .control-group h3 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .btn {
            width: 100%;
            padding: 15px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 10px;
        }
        .btn:hover { background: #ff6b6b; }
        .btn.secondary {
            background: transparent;
            border: 2px solid #e94560;
            color: #e94560;
        }
        .btn.secondary:hover {
            background: rgba(233, 69, 96, 0.2);
        }
        .year-display {
            font-size: 64px;
            text-align: center;
            color: #e94560;
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        .legend {
            margin-top: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
        }
        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .stats-box {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #0f3460;
            font-size: 13px;
        }
        .stat-value { color: #4ecca3; font-weight: bold; }
        .explanation {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.6;
            color: #aaa;
            margin-top: 15px;
        }
        .explanation strong { color: #4ecca3; }
        .hub-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .hub-btn {
            padding: 8px;
            border: 2px solid #0f3460;
            background: #1a1a2e;
            color: #aaa;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .hub-btn:hover {
            border-color: #e94560;
            color: #e94560;
        }
        .hub-btn.active {
            border-color: #e94560;
            background: #e94560;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Demo: Gravitational Pull Animation</h1>
        <p>Watch railway hubs "pull" connected settlements closer. The railway network acts like gravity, compressing space-time around major centers.</p>
    </div>
    <div class="container">
        <canvas id="canvas"></canvas>
        <div class="sidebar">
            <div class="control-group">
                <h3>ANIMATION</h3>
                <button class="btn" id="animateBtn">Start Gravity Animation</button>
                <button class="btn secondary" id="resetBtn">Reset to Geographic</button>
            </div>

            <div class="control-group">
                <h3>GRAVITY HUBS</h3>
                <p style="font-size: 12px; color: #888; margin-bottom: 10px;">Major railway junctions that pull connected settlements:</p>
                <div class="hub-select">
                    <button class="hub-btn active" data-hub="Saskatoon">Saskatoon</button>
                    <button class="hub-btn active" data-hub="Regina">Regina</button>
                    <button class="hub-btn active" data-hub="Moosejaw">Moose Jaw</button>
                    <button class="hub-btn active" data-hub="Prince Albert">Prince Albert</button>
                </div>
            </div>

            <div class="control-group">
                <h3>YEAR</h3>
                <div class="year-display" id="yearDisplay">1920</div>
                <input type="range" id="yearSlider" min="1882" max="1920" value="1920">
            </div>

            <div class="control-group">
                <h3>GRAVITY STRENGTH</h3>
                <input type="range" id="gravitySlider" min="1" max="10" value="5">
                <p style="font-size: 11px; color: #666; margin-top: 5px;">
                    How strongly railways compress distances
                </p>
            </div>

            <div class="stats-box">
                <div class="stat-row">
                    <span>Space compression:</span>
                    <span class="stat-value" id="compressionRatio">1.0x</span>
                </div>
                <div class="stat-row">
                    <span>Avg travel to hub:</span>
                    <span class="stat-value" id="avgTravelTime">-</span>
                </div>
                <div class="stat-row">
                    <span>Within 2 hrs of hub:</span>
                    <span class="stat-value" id="accessibleCount">0%</span>
                </div>
                <div class="stat-row">
                    <span>Time saved vs walking:</span>
                    <span class="stat-value" id="timeSaved">0%</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: #e94560; width: 20px; height: 20px;"></div>
                    <span>Gravity hub (railway junction)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #4ecca3;"></div>
                    <span>&lt;1 hr to hub (40 km)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #ffd93d;"></div>
                    <span>1-2 hrs to hub (40-80 km)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #ff9f43;"></div>
                    <span>2-4 hrs to hub (80-160 km)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: #666;"></div>
                    <span>&gt;4 hrs or no railway</span>
                </div>
            </div>

            <div class="explanation">
                <strong>The Gravity Metaphor:</strong><br><br>
                Railway junctions act like "gravity wells." Connected settlements are pulled toward hubs proportional to how fast railways could reach them.<br><br>
                Isolated settlements (no railway) drift to the edges, representing their relative remoteness in travel time.<br><br>
                This visualizes how railways restructured the perceived geography of Saskatchewan.
            </div>

            <div class="explanation">
                <strong>How the Simulation Works:</strong><br><br>
                <strong style="color: #4ecca3;">Connected settlements</strong> find their nearest hub and are pulled toward it. The pull strengthens with distance (like a spring).<br><br>
                <strong style="color: #666;">Isolated settlements</strong> receive a gentle push away from the center, drifting to the edges.<br><br>
                <strong style="color: #e94560;">Hubs</strong> stay anchored near their geographic positions.<br><br>
                Friction slows all movement to prevent endless bouncing. The "Gravity Strength" slider scales all forces.
            </div>
        </div>
    </div>

    <script>
        let data = null;
        let settlements = [];
        let animating = false;
        let animationId = null;
        let currentYear = 1920;
        let gravityStrength = 0.5;
        let activeHubs = new Set(['Saskatoon', 'Regina', 'Moosejaw', 'Prince Albert']);

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        async function loadData() {
            const response = await fetch('data/settlement_connections.json');
            data = await response.json();
            initSettlements();
            resizeCanvas();
            draw();
        }

        // Haversine distance in km
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        // Pixels per km for current view
        let pixelsPerKm = 1;

        function initSettlements() {
            settlements = [];

            // Calculate bounds
            let minLat = Infinity, maxLat = -Infinity;
            let minLon = Infinity, maxLon = -Infinity;

            Object.values(data.settlements).forEach(s => {
                minLat = Math.min(minLat, s.lat);
                maxLat = Math.max(maxLat, s.lat);
                minLon = Math.min(minLon, s.lon);
                maxLon = Math.max(maxLon, s.lon);
            });

            const padding = 80;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;

            // Calculate pixels per km (approximate)
            const latSpanKm = haversine(minLat, minLon, maxLat, minLon);
            pixelsPerKm = height / latSpanKm;

            Object.entries(data.settlements).forEach(([name, s]) => {
                const geoX = padding + ((s.lon - minLon) / (maxLon - minLon)) * width;
                const geoY = padding + ((maxLat - s.lat) / (maxLat - minLat)) * height;

                const isHub = activeHubs.has(name);
                const hasRailway = s.railway_arrives && s.railway_arrives <= currentYear;

                settlements.push({
                    name,
                    geoX, geoY,
                    x: geoX, y: geoY,  // Current animated position
                    vx: 0, vy: 0,      // Velocity
                    isHub,
                    hasRailway,
                    railwayArrives: s.railway_arrives,
                    lat: s.lat, lon: s.lon,
                    distToHubKm: Infinity,
                    travelTimeHrs: Infinity
                });
            });

            calculateAccessibility();
            updateStats();
        }

        function calculateAccessibility() {
            const hubs = settlements.filter(s => s.isHub && activeHubs.has(s.name));

            settlements.forEach(s => {
                if (s.isHub) {
                    s.distToHubKm = 0;
                    s.travelTimeHrs = 0;
                    return;
                }

                // Find nearest hub (geographic distance)
                let nearestDistKm = Infinity;
                hubs.forEach(hub => {
                    const distKm = haversine(s.lat, s.lon, hub.lat, hub.lon);
                    if (distKm < nearestDistKm) {
                        nearestDistKm = distKm;
                    }
                });

                s.distToHubKm = nearestDistKm;

                // Calculate travel time based on mode
                if (s.hasRailway) {
                    // Railway: 40 km/h
                    s.travelTimeHrs = nearestDistKm / 40;
                } else {
                    // Walking: 5 km/h
                    s.travelTimeHrs = nearestDistKm / 5;
                }
            });
        }

        function getAccessibilityColor(settlement) {
            if (settlement.isHub) return '#e94560';
            if (!settlement.hasRailway) return '#666';

            const hours = settlement.travelTimeHrs;
            if (hours <= 1) return '#4ecca3';      // Green: <1 hr
            if (hours <= 2) return '#ffd93d';      // Yellow: 1-2 hrs
            if (hours <= 4) return '#ff9f43';      // Orange: 2-4 hrs
            return '#666';                          // Gray: >4 hrs
        }

        function updateStats() {
            let totalRailwayTime = 0;
            let totalWalkingTime = 0;
            let within2hrs = 0;
            let count = 0;

            settlements.forEach(s => {
                if (s.isHub) return;
                count++;

                const distKm = s.distToHubKm;
                const walkingTime = distKm / 5;  // 5 km/h
                const railwayTime = s.hasRailway ? distKm / 40 : walkingTime;  // 40 km/h if railway

                totalWalkingTime += walkingTime;
                totalRailwayTime += railwayTime;

                if (railwayTime <= 2) within2hrs++;
            });

            // Space compression ratio
            const compression = totalWalkingTime > 0 ? (totalWalkingTime / totalRailwayTime).toFixed(1) : 1;
            document.getElementById('compressionRatio').textContent = compression + 'x';

            // Average travel time
            const avgTime = count > 0 ? (totalRailwayTime / count).toFixed(1) : 0;
            document.getElementById('avgTravelTime').textContent = avgTime + ' hrs';

            // Percentage within 2 hours
            const accessiblePct = count > 0 ? Math.round((within2hrs / count) * 100) : 0;
            document.getElementById('accessibleCount').textContent = accessiblePct + '%';

            // Time saved vs walking
            const timeSavedPct = totalWalkingTime > 0 ? Math.round((1 - totalRailwayTime / totalWalkingTime) * 100) : 0;
            document.getElementById('timeSaved').textContent = timeSavedPct + '%';
        }

        function calculateGravity() {
            const hubs = settlements.filter(s => s.isHub && activeHubs.has(s.name));
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            settlements.forEach(s => {
                if (s.isHub) {
                    // Hubs stay near their geographic positions but move slightly toward center
                    const dx = s.geoX - s.x;
                    const dy = s.geoY - s.y;
                    s.vx += dx * 0.02;
                    s.vy += dy * 0.02;
                    return;
                }

                if (s.hasRailway) {
                    // Connected settlements are pulled toward nearest hub
                    let nearestHub = null;
                    let nearestDist = Infinity;

                    hubs.forEach(hub => {
                        const dist = Math.hypot(hub.geoX - s.geoX, hub.geoY - s.geoY);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestHub = hub;
                        }
                    });

                    if (nearestHub) {
                        // Pull toward hub
                        const dx = nearestHub.x - s.x;
                        const dy = nearestHub.y - s.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist > 20) {
                            const force = gravityStrength * 0.03;
                            s.vx += (dx / dist) * force * dist * 0.01;
                            s.vy += (dy / dist) * force * dist * 0.01;
                        }
                    }
                } else {
                    // Isolated settlements drift outward from center
                    const dx = s.x - centerX;
                    const dy = s.y - centerY;
                    const dist = Math.hypot(dx, dy);

                    if (dist > 10) {
                        const force = gravityStrength * 0.005;
                        s.vx += (dx / dist) * force;
                        s.vy += (dy / dist) * force;
                    }
                }

                // Apply friction
                s.vx *= 0.95;
                s.vy *= 0.95;
            });

            // Update positions
            settlements.forEach(s => {
                s.x += s.vx;
                s.y += s.vy;

                // Keep in bounds
                s.x = Math.max(20, Math.min(canvas.width - 20, s.x));
                s.y = Math.max(20, Math.min(canvas.height - 20, s.y));
            });

            // Calculate average pull distance
            let totalPull = 0;
            let pullCount = 0;
            settlements.forEach(s => {
                if (!s.isHub) {
                    const pull = Math.hypot(s.x - s.geoX, s.y - s.geoY);
                    totalPull += pull;
                    pullCount++;
                }
            });
            const avgPull = pullCount > 0 ? (totalPull / pullCount) : 0;
            document.getElementById('avgPull').textContent = Math.round(avgPull) + ' px';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const hubs = settlements.filter(s => s.isHub && activeHubs.has(s.name));

            // Draw time rings around hubs (1hr, 2hr, 4hr at 40 km/h)
            const timeRings = [
                { hours: 1, km: 40, color: 'rgba(78, 204, 163, 0.15)', label: '1 hr' },
                { hours: 2, km: 80, color: 'rgba(255, 217, 61, 0.1)', label: '2 hrs' },
                { hours: 4, km: 160, color: 'rgba(255, 159, 67, 0.08)', label: '4 hrs' }
            ];

            // Draw rings largest first
            [...timeRings].reverse().forEach(ring => {
                const radiusPx = ring.km * pixelsPerKm;
                hubs.forEach(hub => {
                    ctx.beginPath();
                    ctx.arc(hub.x, hub.y, radiusPx, 0, Math.PI * 2);
                    ctx.fillStyle = ring.color;
                    ctx.fill();
                    ctx.strokeStyle = ring.color.replace(/[\d.]+\)$/, '0.4)');
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            });

            // Draw ring labels for first hub
            if (hubs.length > 0) {
                const hub = hubs[0];
                ctx.font = '10px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                timeRings.forEach(ring => {
                    const radiusPx = ring.km * pixelsPerKm;
                    ctx.fillText(ring.label + ' (' + ring.km + ' km)', hub.x + radiusPx + 5, hub.y);
                });
            }

            // Draw connections to hubs (faint lines)
            ctx.strokeStyle = 'rgba(78, 204, 163, 0.1)';
            ctx.lineWidth = 1;

            settlements.forEach(s => {
                if (!s.isHub && s.hasRailway) {
                    let nearestHub = null;
                    let nearestDist = Infinity;
                    hubs.forEach(hub => {
                        const dist = Math.hypot(hub.x - s.x, hub.y - s.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestHub = hub;
                        }
                    });
                    if (nearestHub) {
                        ctx.beginPath();
                        ctx.moveTo(s.x, s.y);
                        ctx.lineTo(nearestHub.x, nearestHub.y);
                        ctx.stroke();
                    }
                }
            });

            // Draw settlements (non-hubs first) with accessibility colors
            settlements.filter(s => !s.isHub).forEach(s => {
                ctx.beginPath();
                const radius = s.hasRailway ? 4 : 3;
                ctx.arc(s.x, s.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = getAccessibilityColor(s);
                ctx.fill();
            });

            // Draw hubs (on top)
            settlements.filter(s => s.isHub && activeHubs.has(s.name)).forEach(s => {
                // Glow effect
                const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, 40);
                gradient.addColorStop(0, 'rgba(233, 69, 96, 0.3)');
                gradient.addColorStop(1, 'rgba(233, 69, 96, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(s.x, s.y, 40, 0, Math.PI * 2);
                ctx.fill();

                // Hub dot
                ctx.beginPath();
                ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = '#e94560';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(s.name, s.x, s.y - 18);
            });

            if (animating) {
                calculateGravity();
                animationId = requestAnimationFrame(draw);
            }
        }

        function startAnimation() {
            if (animating) {
                animating = false;
                document.getElementById('animateBtn').textContent = 'Resume Animation';
            } else {
                animating = true;
                document.getElementById('animateBtn').textContent = 'Pause Animation';
                draw();
            }
        }

        function reset() {
            animating = false;
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('animateBtn').textContent = 'Start Gravity Animation';

            settlements.forEach(s => {
                s.x = s.geoX;
                s.y = s.geoY;
                s.vx = 0;
                s.vy = 0;
            });

            draw();
        }

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            if (data) {
                initSettlements();
                draw();
            }
        }

        // Event listeners
        document.getElementById('animateBtn').addEventListener('click', startAnimation);
        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('yearSlider').addEventListener('input', (e) => {
            currentYear = parseInt(e.target.value);
            document.getElementById('yearDisplay').textContent = currentYear;

            settlements.forEach(s => {
                s.hasRailway = s.railwayArrives && s.railwayArrives <= currentYear;
            });
            calculateAccessibility();
            updateStats();
            if (!animating) draw();
        });

        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            gravityStrength = parseInt(e.target.value) / 10;
        });

        document.querySelectorAll('.hub-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                const hub = btn.dataset.hub;
                if (activeHubs.has(hub)) {
                    activeHubs.delete(hub);
                } else {
                    activeHubs.add(hub);
                }
                settlements.forEach(s => {
                    s.isHub = activeHubs.has(s.name);
                });
                calculateAccessibility();
                updateStats();
                if (!animating) draw();
            });
        });

        window.addEventListener('resize', resizeCanvas);

        // Initialize
        loadData();
    </script>
</body>
</html>
