<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settlement Explorer: One-Hour Railway Connections</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
        }
        .header {
            background: #16213e;
            padding: 20px;
            text-align: center;
            border-bottom: 3px solid #e94560;
        }
        .header h1 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .header p {
            color: #aaa;
            max-width: 800px;
            margin: 0 auto;
        }
        .nav {
            background: #0f3460;
            padding: 10px;
            text-align: center;
        }
        .nav a {
            color: #e94560;
            text-decoration: none;
            margin: 0 15px;
            padding: 5px 15px;
            border: 1px solid #e94560;
            border-radius: 3px;
            transition: all 0.3s;
        }
        .nav a:hover {
            background: #e94560;
            color: #fff;
        }
        .container {
            display: flex;
            height: calc(100vh - 160px);
        }
        #map {
            flex: 1;
            height: 100%;
        }
        .sidebar {
            width: 350px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
        }
        .settlement-selector {
            margin-bottom: 20px;
        }
        .settlement-selector label {
            display: block;
            margin-bottom: 10px;
            color: #e94560;
            font-weight: bold;
        }
        .settlement-selector input {
            width: 100%;
            padding: 12px;
            border: 2px solid #0f3460;
            border-radius: 5px;
            background: #1a1a2e;
            color: #eee;
            font-size: 16px;
        }
        .settlement-selector input:focus {
            outline: none;
            border-color: #e94560;
        }
        .selected-info {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 3px solid #e94560;
        }
        .selected-info h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .selected-info p {
            color: #ccc;
            margin: 5px 0;
        }
        .selected-info .railway-tag {
            display: inline-block;
            background: #4ecca3;
            color: #1a1a2e;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin: 2px;
            font-weight: bold;
        }
        .selected-info .railway-tag.future {
            background: #666;
            color: #aaa;
        }
        .controls {
            margin-bottom: 20px;
        }
        .controls label {
            display: block;
            margin-bottom: 10px;
            color: #e94560;
            font-weight: bold;
        }
        .year-display {
            font-size: 48px;
            text-align: center;
            color: #e94560;
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        .stats {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .stats h3 {
            color: #e94560;
            margin-bottom: 10px;
            border-bottom: 1px solid #e94560;
            padding-bottom: 5px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        .stat-item .value {
            font-weight: bold;
        }
        .stat-item .connected {
            color: #4ecca3;
        }
        .stat-item .pending {
            color: #666;
        }
        .stat-item .new {
            color: #ffcc00;
        }
        .settlement-list {
            margin-top: 20px;
        }
        .settlement-list h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .settlement-item {
            background: #0f3460;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            border-left: 3px solid #4ecca3;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .settlement-item:hover {
            transform: translateX(5px);
        }
        .settlement-item.pending {
            border-left-color: #666;
            opacity: 0.7;
        }
        .settlement-item.new-connection {
            border-left-color: #ffcc00;
            animation: pulse 1s ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { background: #0f3460; }
            50% { background: #1a4a3e; }
        }
        .settlement-item .name {
            font-weight: bold;
        }
        .settlement-item .details {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        .settlement-item .new-badge {
            display: inline-block;
            background: #ffcc00;
            color: #1a1a2e;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 5px;
            font-weight: bold;
        }
        .legend {
            background: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .legend h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 13px;
        }
        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .play-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .play-controls button {
            background: #e94560;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .play-controls button:hover {
            background: #ff6b6b;
        }
        .no-connections {
            color: #888;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Settlement Explorer: One-Hour Railway Connections</h1>
        <p>Select any Saskatchewan settlement to see nearby settlements within 40 km (straight-line distance). Shows both direct distance and actual railway distance where available. Use the time slider to see how connectivity evolved from 1882 to 1920.</p>
    </div>
    <div class="nav">
        <a href="index.html">Home</a>
        <a href="one_hour_map.html">Saskatoon Corridor</a>
        <a href="settlement_explorer.html">Settlement Explorer</a>
        <a href="railway_timeline.html">Railway Timeline</a>
        <a href="network_graph.html">Network Graph</a>
    </div>
    <div class="container">
        <div id="map"></div>
        <div class="sidebar">
            <div class="settlement-selector">
                <label for="settlementSearch">Search Settlement:</label>
                <input type="text" id="settlementSearch" list="settlementList" placeholder="Type to search...">
                <datalist id="settlementList"></datalist>
            </div>

            <div class="selected-info" id="selectedInfo">
                <h3>Selected Settlement</h3>
                <p id="selectedName">None selected</p>
                <div id="selectedRailways"></div>
            </div>

            <div class="controls">
                <label>Select Year:</label>
                <div class="year-display" id="yearDisplay">1890</div>
                <input type="range" id="yearSlider" min="1882" max="1920" step="1" value="1890">
                <div class="play-controls">
                    <button id="playBtn">Play</button>
                    <button id="resetBtn">Reset</button>
                </div>
            </div>

            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-item">
                    <span>Within 40 km:</span>
                    <span id="totalCount" class="value">0</span>
                </div>
                <div class="stat-item">
                    <span>Connected by rail:</span>
                    <span id="connectedCount" class="value connected">0</span>
                </div>
                <div class="stat-item">
                    <span>New this year:</span>
                    <span id="newCount" class="value new">0</span>
                </div>
                <div class="stat-item">
                    <span>Pending/No shared rail:</span>
                    <span id="pendingCount" class="value pending">0</span>
                </div>
            </div>

            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #e94560;"></div>
                    <span>Selected Settlement</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #4ecca3;"></div>
                    <span>Connected (within 40km)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #ffcc00;"></div>
                    <span>Newly Connected This Year</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #888;"></div>
                    <span>Within 40km (pending)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: #444; width: 8px; height: 8px;"></div>
                    <span>Other Settlements</span>
                </div>
                <div class="legend-item">
                    <div style="width:12px; height:12px; background:#ffaa00; transform:rotate(45deg); border:2px solid #fff; margin-right:10px;"></div>
                    <span>Multi-Railway Junction</span>
                </div>
                <div class="legend-item">
                    <div class="legend-circle" style="background: transparent; border: 2px dashed #e94560;"></div>
                    <span>40 km Radius</span>
                </div>
                <div class="legend-item">
                    <div style="width: 20px; height: 3px; background: #4ecca3; margin-right: 10px;"></div>
                    <span>Railway Route</span>
                </div>
            </div>

            <div class="settlement-list">
                <h3>Nearby Settlements</h3>
                <div id="settlementListItems"></div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let data = null;
        let trackData = null;         // Railway track geometry
        let networkData = null;       // Railway network (nodes/edges)
        let mappingData = null;       // Settlement to node mappings
        let map = null;
        let allMarkers = {};          // All settlement markers
        let nearbyMarkers = {};       // Markers within 40km of selected
        let connectionLines = [];     // Lines between connected settlements
        let selectedMarker = null;
        let radiusCircle = null;
        let isPlaying = false;
        let playInterval = null;
        let currentSettlement = null;
        let previousYear = null;

        // Helper function to check if settlement has multiple railways
        function hasMultipleRailways(settlementName) {
            const s = data.settlements[settlementName];
            return s && s.railways && s.railways.length > 1;
        }

        // Helper function to get railway count
        function getRailwayCount(settlementName) {
            const s = data.settlements[settlementName];
            return (s && s.railways) ? s.railways.length : 0;
        }

        // Initialize map centered on Saskatchewan
        function initMap() {
            map = L.map('map').setView([52.0, -106.0], 6);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
        }

        // Load data
        async function loadData() {
            try {
                console.log('Loading data...');

                // Load settlement connections
                const response = await fetch('data/settlement_connections.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                data = await response.json();
                console.log('Data loaded:', Object.keys(data.settlements).length, 'settlements');

                // Load railway track geometry
                try {
                    const trackResponse = await fetch('data/railway_tracks.json');
                    if (trackResponse.ok) {
                        trackData = await trackResponse.json();
                        console.log('Track geometry loaded:', trackData.track_count, 'segments');
                        // Build lookup by edge key
                        trackData.lookup = {};
                        trackData.tracks.forEach(t => {
                            trackData.lookup[`${t.source}|${t.target}`] = t;
                            trackData.lookup[`${t.target}|${t.source}`] = t; // Both directions
                        });
                    }
                } catch (e) {
                    console.warn('Could not load track geometry:', e);
                }
                // Load network graph for pathfinding
                try {
                    const networkResponse = await fetch('data/railway_network.json');
                    if (networkResponse.ok) {
                        networkData = await networkResponse.json();
                        console.log('Network loaded:', networkData.stats.node_count, 'nodes');
                        // Build adjacency list for pathfinding
                        networkData.adj = {};
                        networkData.edges.forEach(e => {
                            if (!networkData.adj[e.source]) networkData.adj[e.source] = [];
                            if (!networkData.adj[e.target]) networkData.adj[e.target] = [];
                            networkData.adj[e.source].push({node: e.target, weight: e.length_m});
                            networkData.adj[e.target].push({node: e.source, weight: e.length_m});
                        });
                    }
                } catch (e) {
                    console.warn('Could not load network:', e);
                }

                // Load settlement to node mappings
                try {
                    const mappingResponse = await fetch('data/settlement_network_mapping.json');
                    if (mappingResponse.ok) {
                        mappingData = await mappingResponse.json();
                        console.log('Mappings loaded:', mappingData.mappings.length, 'settlements');
                        // Build lookup by settlement name
                        mappingData.lookup = {};
                        mappingData.mappings.forEach(m => {
                            mappingData.lookup[m.settlement] = m;
                        });
                    }
                } catch (e) {
                    console.warn('Could not load mappings:', e);
                }

                initSettlementSelector();
                addAllSettlementMarkers();

                // Select Saskatoon by default
                if (data.settlements['Saskatoon']) {
                    selectSettlement('Saskatoon');
                }
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('selectedName').textContent = 'Error loading data';
                document.getElementById('selectedRailways').innerHTML =
                    '<span style="color: #e94560;">Try: python -m http.server 8080</span>';
            }
        }

        // Calculate distance between two lat/lon points in meters (Haversine)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Find intersection point of line segment with circle boundary using binary search
        function findCircleIntersection(pt1, pt2, centerLat, centerLon, radiusM) {
            const dist1 = haversineDistance(centerLat, centerLon, pt1[0], pt1[1]);
            const dist2 = haversineDistance(centerLat, centerLon, pt2[0], pt2[1]);

            let lo = 0, hi = 1;
            for (let iter = 0; iter < 20; iter++) {
                const mid = (lo + hi) / 2;
                const lat = pt1[0] + (pt2[0] - pt1[0]) * mid;
                const lon = pt1[1] + (pt2[1] - pt1[1]) * mid;
                const dist = haversineDistance(centerLat, centerLon, lat, lon);

                if (dist < radiusM) {
                    if (dist1 < radiusM) lo = mid;
                    else hi = mid;
                } else {
                    if (dist1 < radiusM) hi = mid;
                    else lo = mid;
                }
            }

            const t = (lo + hi) / 2;
            return [pt1[0] + (pt2[0] - pt1[0]) * t, pt1[1] + (pt2[1] - pt1[1]) * t];
        }

        // Clip a polyline to stay within a circle
        function clipPolylineToCircle(coords, centerLat, centerLon, radiusM) {
            if (!coords || coords.length < 2) return coords;

            const clipped = [];

            for (let i = 0; i < coords.length; i++) {
                const pt = coords[i];
                const dist = haversineDistance(centerLat, centerLon, pt[0], pt[1]);
                const isInside = dist <= radiusM;

                if (i === 0) {
                    if (isInside) clipped.push(pt);
                } else {
                    const prevPt = coords[i - 1];
                    const prevDist = haversineDistance(centerLat, centerLon, prevPt[0], prevPt[1]);
                    const prevInside = prevDist <= radiusM;

                    if (isInside && prevInside) {
                        clipped.push(pt);
                    } else if (isInside && !prevInside) {
                        const intersect = findCircleIntersection(prevPt, pt, centerLat, centerLon, radiusM);
                        clipped.push(intersect);
                        clipped.push(pt);
                    } else if (!isInside && prevInside) {
                        const intersect = findCircleIntersection(prevPt, pt, centerLat, centerLon, radiusM);
                        clipped.push(intersect);
                    }
                    // Both outside: skip (handle pass-through if needed)
                }
            }

            return clipped.length >= 2 ? clipped : null;
        }

        // Find shortest path between two nodes using Dijkstra
        function findPath(startNode, endNode) {
            if (!networkData || !networkData.adj) return null;
            if (startNode === endNode) return [startNode];

            const dist = {};
            const prev = {};
            const visited = new Set();
            const queue = [];

            dist[startNode] = 0;
            queue.push({node: startNode, dist: 0});

            while (queue.length > 0) {
                // Sort by distance (simple priority queue)
                queue.sort((a, b) => a.dist - b.dist);
                const {node: current} = queue.shift();

                if (visited.has(current)) continue;
                visited.add(current);

                if (current === endNode) break;

                const neighbors = networkData.adj[current] || [];
                for (const {node: neighbor, weight} of neighbors) {
                    if (visited.has(neighbor)) continue;
                    const newDist = dist[current] + weight;
                    if (dist[neighbor] === undefined || newDist < dist[neighbor]) {
                        dist[neighbor] = newDist;
                        prev[neighbor] = current;
                        queue.push({node: neighbor, dist: newDist});
                    }
                }
            }

            if (prev[endNode] === undefined && startNode !== endNode) return null;

            // Reconstruct path
            const path = [];
            let current = endNode;
            while (current !== undefined) {
                path.unshift(current);
                current = prev[current];
            }
            return path;
        }

        // Get track geometry for a path (list of nodes)
        function getPathGeometry(path) {
            if (!path || path.length < 2 || !trackData || !trackData.lookup) return null;

            const allCoords = [];
            for (let i = 0; i < path.length - 1; i++) {
                const key = `${path[i]}|${path[i+1]}`;
                const track = trackData.lookup[key];
                if (track && track.coordinates) {
                    // Check if we need to reverse the coordinates
                    let coords = track.coordinates.map(c => [c[1], c[0]]); // [lat, lon]

                    // If this isn't the first segment, check if we need to reverse
                    if (allCoords.length > 0) {
                        const lastPoint = allCoords[allCoords.length - 1];
                        const firstPoint = coords[0];
                        const lastPointReversed = coords[coords.length - 1];

                        // Check which end connects better
                        const distToFirst = Math.abs(lastPoint[0] - firstPoint[0]) + Math.abs(lastPoint[1] - firstPoint[1]);
                        const distToLast = Math.abs(lastPoint[0] - lastPointReversed[0]) + Math.abs(lastPoint[1] - lastPointReversed[1]);

                        if (distToLast < distToFirst) {
                            coords = coords.reverse();
                        }
                    }

                    allCoords.push(...coords);
                }
            }
            return allCoords.length > 0 ? allCoords : null;
        }

        // Find the index of the point on a path closest to a given location
        function findClosestPointIndex(coords, targetLat, targetLon) {
            let minDist = Infinity;
            let minIndex = 0;
            for (let i = 0; i < coords.length; i++) {
                const dist = haversineDistance(coords[i][0], coords[i][1], targetLat, targetLon);
                if (dist < minDist) {
                    minDist = dist;
                    minIndex = i;
                }
            }
            return minIndex;
        }

        // Trim path to start and end at settlement locations
        function trimPathToSettlements(coords, fromLat, fromLon, toLat, toLon) {
            if (!coords || coords.length < 2) return coords;

            // Find closest points to start and end settlements
            const startIndex = findClosestPointIndex(coords, fromLat, fromLon);
            const endIndex = findClosestPointIndex(coords, toLat, toLon);

            // Ensure we go in the right direction
            let trimmedCoords;
            if (startIndex <= endIndex) {
                trimmedCoords = coords.slice(startIndex, endIndex + 1);
            } else {
                trimmedCoords = coords.slice(endIndex, startIndex + 1).reverse();
            }

            // Replace first and last points with actual settlement coordinates
            if (trimmedCoords.length >= 2) {
                trimmedCoords[0] = [fromLat, fromLon];
                trimmedCoords[trimmedCoords.length - 1] = [toLat, toLon];
            }

            return trimmedCoords;
        }

        // Extend path geometry to include partial edge when settlement is snapped mid-edge
        function extendPathToEdge(coords, mapping, settlementLat, settlementLon, atEnd) {
            // Only extend if settlement is snapped to an edge (not a node)
            if (!mapping.snap_nodes || mapping.snap_nodes.length !== 2) return coords;

            const [node1, node2] = mapping.snap_nodes;
            const edgeKey1 = `${node1}|${node2}`;
            const edgeKey2 = `${node2}|${node1}`;

            const track = trackData.lookup[edgeKey1] || trackData.lookup[edgeKey2];
            if (!track || !track.coordinates) return coords;

            // Convert track coords to [lat, lon] format
            let trackCoords = track.coordinates.map(c => [c[1], c[0]]);

            // Find the point on this track closest to the settlement
            let minDist = Infinity;
            let closestIdx = 0;
            for (let i = 0; i < trackCoords.length; i++) {
                const dist = haversineDistance(trackCoords[i][0], trackCoords[i][1], settlementLat, settlementLon);
                if (dist < minDist) {
                    minDist = dist;
                    closestIdx = i;
                }
            }

            // Check if extending would actually help (closest point should be closer than current endpoint)
            const currentEndpoint = atEnd ? coords[coords.length - 1] : coords[0];
            const currentDist = haversineDistance(currentEndpoint[0], currentEndpoint[1], settlementLat, settlementLon);

            if (minDist >= currentDist) {
                // Extension wouldn't help
                return coords;
            }

            // Determine which end of the track connects to our path
            const pathEndpoint = atEnd ? coords[coords.length - 1] : coords[0];
            const distToTrackStart = Math.abs(pathEndpoint[0] - trackCoords[0][0]) + Math.abs(pathEndpoint[1] - trackCoords[0][1]);
            const distToTrackEnd = Math.abs(pathEndpoint[0] - trackCoords[trackCoords.length-1][0]) + Math.abs(pathEndpoint[1] - trackCoords[trackCoords.length-1][1]);

            let extensionCoords;
            if (distToTrackStart < distToTrackEnd) {
                // Track starts near our path endpoint, take from start to closest point
                extensionCoords = trackCoords.slice(0, closestIdx + 1);
            } else {
                // Track ends near our path endpoint, take from closest point to end (reversed)
                extensionCoords = trackCoords.slice(closestIdx).reverse();
            }

            // Append or prepend the extension
            if (atEnd) {
                // Skip first point of extension (it overlaps with path end)
                return [...coords, ...extensionCoords.slice(1)];
            } else {
                // Skip last point of extension (it overlaps with path start)
                return [...extensionCoords.slice(0, -1), ...coords];
            }
        }

        // Check if two arrays of node IDs represent the same edge
        function isSameEdge(nodes1, nodes2) {
            if (!nodes1 || !nodes2 || nodes1.length !== 2 || nodes2.length !== 2) return false;
            return (nodes1[0] === nodes2[0] && nodes1[1] === nodes2[1]) ||
                   (nodes1[0] === nodes2[1] && nodes1[1] === nodes2[0]);
        }

        // Get geometry for two settlements on the same edge
        function getSameEdgeGeometry(fromMapping, toMapping, fromLat, fromLon, toLat, toLon) {
            // Both must be snapped to edges
            if (!fromMapping.snap_nodes || !toMapping.snap_nodes) return null;
            if (fromMapping.snap_nodes.length !== 2 || toMapping.snap_nodes.length !== 2) return null;

            // Check if they're on the same edge
            if (!isSameEdge(fromMapping.snap_nodes, toMapping.snap_nodes)) return null;

            const [node1, node2] = fromMapping.snap_nodes;
            const edgeKey = `${node1}|${node2}`;
            const track = trackData.lookup[edgeKey] || trackData.lookup[`${node2}|${node1}`];

            if (!track || !track.coordinates) return null;

            // Convert to [lat, lon] format
            const trackCoords = track.coordinates.map(c => [c[1], c[0]]);

            // Find closest points to each settlement
            let fromIdx = 0, toIdx = 0;
            let fromMinDist = Infinity, toMinDist = Infinity;

            for (let i = 0; i < trackCoords.length; i++) {
                const fromDist = haversineDistance(trackCoords[i][0], trackCoords[i][1], fromLat, fromLon);
                const toDist = haversineDistance(trackCoords[i][0], trackCoords[i][1], toLat, toLon);

                if (fromDist < fromMinDist) {
                    fromMinDist = fromDist;
                    fromIdx = i;
                }
                if (toDist < toMinDist) {
                    toMinDist = toDist;
                    toIdx = i;
                }
            }

            // Extract the portion between the two indices
            let coords;
            if (fromIdx <= toIdx) {
                coords = trackCoords.slice(fromIdx, toIdx + 1);
            } else {
                coords = trackCoords.slice(toIdx, fromIdx + 1).reverse();
            }

            // If both settlements project to the same point (sparse track geometry),
            // create a simple 2-point path through the closest track point
            if (coords.length < 2) {
                const trackPoint = trackCoords[fromIdx];
                return [[fromLat, fromLon], trackPoint, [toLat, toLon]];
            }

            return coords;
        }

        // Get geometry for settlements on different edges meeting at a shared node
        function getSharedNodeGeometry(fromMapping, toMapping, fromLat, fromLon, toLat, toLon) {
            // Both must be snapped to edges
            if (!fromMapping.snap_nodes || !toMapping.snap_nodes) return null;
            if (fromMapping.snap_nodes.length !== 2 || toMapping.snap_nodes.length !== 2) return null;

            // Must share the same snap_node but be on different edges
            if (fromMapping.snap_node !== toMapping.snap_node) return null;
            if (isSameEdge(fromMapping.snap_nodes, toMapping.snap_nodes)) return null;

            // Get track geometry for the "from" edge
            const [fromNode1, fromNode2] = fromMapping.snap_nodes;
            const fromEdgeKey = `${fromNode1}|${fromNode2}`;
            const fromTrack = trackData.lookup[fromEdgeKey] || trackData.lookup[`${fromNode2}|${fromNode1}`];

            // Get track geometry for the "to" edge
            const [toNode1, toNode2] = toMapping.snap_nodes;
            const toEdgeKey = `${toNode1}|${toNode2}`;
            const toTrack = trackData.lookup[toEdgeKey] || trackData.lookup[`${toNode2}|${toNode1}`];

            if (!fromTrack || !toTrack || !fromTrack.coordinates || !toTrack.coordinates) return null;

            // Convert to [lat, lon]
            const fromCoords = fromTrack.coordinates.map(c => [c[1], c[0]]);
            const toCoords = toTrack.coordinates.map(c => [c[1], c[0]]);

            // Find closest point to "from" settlement on its edge
            let fromIdx = 0, fromMinDist = Infinity;
            for (let i = 0; i < fromCoords.length; i++) {
                const dist = haversineDistance(fromCoords[i][0], fromCoords[i][1], fromLat, fromLon);
                if (dist < fromMinDist) {
                    fromMinDist = dist;
                    fromIdx = i;
                }
            }

            // Find closest point to "to" settlement on its edge
            let toIdx = 0, toMinDist = Infinity;
            for (let i = 0; i < toCoords.length; i++) {
                const dist = haversineDistance(toCoords[i][0], toCoords[i][1], toLat, toLon);
                if (dist < toMinDist) {
                    toMinDist = dist;
                    toIdx = i;
                }
            }

            // Determine which end of each track is the shared node
            // by checking actual coordinate distances (not assuming snap_nodes order matches track direction)
            const sharedNode = fromMapping.snap_node;
            const sharedNodeData = networkData.nodes.find(n => n.id === sharedNode);
            if (!sharedNodeData) return null;

            // For fromTrack: check which end is closer to the shared node
            const fromStartDist = Math.abs(fromCoords[0][0] - sharedNodeData.lat) + Math.abs(fromCoords[0][1] - sharedNodeData.lon);
            const fromEndDist = Math.abs(fromCoords[fromCoords.length-1][0] - sharedNodeData.lat) + Math.abs(fromCoords[fromCoords.length-1][1] - sharedNodeData.lon);
            const fromTrackStartIsShared = fromStartDist < fromEndDist;

            // For toTrack: check which end is closer to the shared node
            const toStartDist = Math.abs(toCoords[0][0] - sharedNodeData.lat) + Math.abs(toCoords[0][1] - sharedNodeData.lon);
            const toEndDist = Math.abs(toCoords[toCoords.length-1][0] - sharedNodeData.lat) + Math.abs(toCoords[toCoords.length-1][1] - sharedNodeData.lon);
            const toTrackStartIsShared = toStartDist < toEndDist;

            // Build path from "from" settlement to shared node
            let fromPortion;
            if (fromTrackStartIsShared) {
                // Shared node is at start of coords, so we need from settlement point back to start
                fromPortion = fromCoords.slice(0, fromIdx + 1).reverse();
            } else {
                // Shared node is at end of coords, so we need from settlement point to end
                fromPortion = fromCoords.slice(fromIdx);
            }

            // Build path from shared node to "to" settlement
            let toPortion;
            if (toTrackStartIsShared) {
                // Shared node is at start of coords, so we go from start to settlement point
                toPortion = toCoords.slice(0, toIdx + 1);
            } else {
                // Shared node is at end of coords, so we go from end (reversed) to settlement point
                toPortion = toCoords.slice(toIdx).reverse();
            }

            // Combine: fromPortion ends at shared node, toPortion starts at shared node
            // Skip duplicate shared node point
            const combined = [...fromPortion, ...toPortion.slice(1)];

            return combined.length >= 2 ? combined : null;
        }

        // Get geometry when one or both settlements are snapped to a node (not an edge)
        function getNodeOnlyGeometry(fromMapping, toMapping, fromLat, fromLon, toLat, toLon) {
            // Must share the same snap_node
            if (fromMapping.snap_node !== toMapping.snap_node) return null;

            const fromIsNodeOnly = !fromMapping.snap_nodes || fromMapping.snap_nodes.length === 1;
            const toIsNodeOnly = !toMapping.snap_nodes || toMapping.snap_nodes.length === 1;

            // At least one must be node-only
            if (!fromIsNodeOnly && !toIsNodeOnly) return null;

            const sharedNode = fromMapping.snap_node;
            const sharedNodeData = networkData.nodes.find(n => n.id === sharedNode);
            if (!sharedNodeData) return null;

            // Case 1: Both are node-only - return line through the node
            if (fromIsNodeOnly && toIsNodeOnly) {
                return [[fromLat, fromLon], [sharedNodeData.lat, sharedNodeData.lon], [toLat, toLon]];
            }

            // Case 2: One is node-only, the other is on an edge containing the node
            // Use the portion of the edge from the node to the settlement
            const edgeMapping = fromIsNodeOnly ? toMapping : fromMapping;
            const edgeLat = fromIsNodeOnly ? toLat : fromLat;
            const edgeLon = fromIsNodeOnly ? toLon : fromLon;
            const nodeLat = fromIsNodeOnly ? fromLat : toLat;
            const nodeLon = fromIsNodeOnly ? fromLon : toLon;

            const [node1, node2] = edgeMapping.snap_nodes;
            const edgeKey = `${node1}|${node2}`;
            const track = trackData.lookup[edgeKey] || trackData.lookup[`${node2}|${node1}`];

            if (!track || !track.coordinates) {
                // Fallback: line through node
                return [[fromLat, fromLon], [sharedNodeData.lat, sharedNodeData.lon], [toLat, toLon]];
            }

            const trackCoords = track.coordinates.map(c => [c[1], c[0]]);

            // Find which end of track is the shared node
            const startDist = Math.abs(trackCoords[0][0] - sharedNodeData.lat) + Math.abs(trackCoords[0][1] - sharedNodeData.lon);
            const endDist = Math.abs(trackCoords[trackCoords.length-1][0] - sharedNodeData.lat) + Math.abs(trackCoords[trackCoords.length-1][1] - sharedNodeData.lon);
            const nodeAtStart = startDist < endDist;

            // Find closest point to edge settlement
            let closestIdx = 0, minDist = Infinity;
            for (let i = 0; i < trackCoords.length; i++) {
                const dist = haversineDistance(trackCoords[i][0], trackCoords[i][1], edgeLat, edgeLon);
                if (dist < minDist) {
                    minDist = dist;
                    closestIdx = i;
                }
            }

            // Extract portion from node to settlement
            let portion;
            if (nodeAtStart) {
                portion = trackCoords.slice(0, closestIdx + 1);
            } else {
                portion = trackCoords.slice(closestIdx).reverse();
            }

            // Build final path: from settlement -> (track portion) -> to settlement
            if (fromIsNodeOnly) {
                // from is node-only: nodeLat,nodeLon -> portion -> edgeLat,edgeLon
                return [[nodeLat, nodeLon], ...portion.slice(1)];
            } else {
                // to is node-only: edgeLat,edgeLon -> portion (reversed) -> nodeLat,nodeLon
                return [...portion.slice(0, -1).reverse(), [nodeLat, nodeLon]];
            }
        }

        // Draw connection using actual railway path
        function drawRailwayConnection(fromSettlement, toSettlement, color, weight, opacity) {
            if (!mappingData || !mappingData.lookup) return null;

            const fromMapping = mappingData.lookup[fromSettlement];
            const toMapping = mappingData.lookup[toSettlement];
            if (!fromMapping || !toMapping) return null;

            // Get actual settlement coordinates
            const fromData = data.settlements[fromSettlement];
            const toData = data.settlements[toSettlement];
            if (!fromData || !toData) return null;

            const fromNode = fromMapping.snap_node;
            const toNode = toMapping.snap_node;

            let coords = null;

            // Case 1: Both settlements on the same snap_node
            if (fromNode === toNode) {
                // Try same-edge geometry first
                coords = getSameEdgeGeometry(fromMapping, toMapping, fromData.lat, fromData.lon, toData.lat, toData.lon);

                // If not same edge, try shared-node geometry (different edges meeting at same node)
                if (!coords) {
                    coords = getSharedNodeGeometry(fromMapping, toMapping, fromData.lat, fromData.lon, toData.lat, toData.lon);
                }

                // If one or both settlements are snapped to node only (not edge), handle that
                if (!coords) {
                    coords = getNodeOnlyGeometry(fromMapping, toMapping, fromData.lat, fromData.lon, toData.lat, toData.lon);
                }
            }

            // Case 2: Different nodes - use pathfinding
            if (!coords) {
                const path = findPath(fromNode, toNode);
                if (!path) return null;

                coords = getPathGeometry(path);

                if (coords && coords.length >= 2) {
                    // Extend path if settlements are snapped to edges
                    coords = extendPathToEdge(coords, fromMapping, fromData.lat, fromData.lon, false);
                    coords = extendPathToEdge(coords, toMapping, toData.lat, toData.lon, true);
                }
            }

            if (!coords || coords.length < 2) return null;

            // Trim path to start and end at settlement locations
            coords = trimPathToSettlements(coords, fromData.lat, fromData.lon, toData.lat, toData.lon);
            if (!coords || coords.length < 2) return null;

            return L.polyline(coords, {
                color: color,
                weight: weight,
                opacity: opacity
            });
        }

        // Add small markers for ALL settlements
        function addAllSettlementMarkers() {
            Object.entries(data.settlements).forEach(([name, settlement]) => {
                const isMultiRailway = hasMultipleRailways(name);
                let marker;

                if (isMultiRailway) {
                    // Diamond shape for multi-railway junctions
                    const diamondIcon = L.divIcon({
                        className: 'multi-railway-marker',
                        html: '<div style="width:12px; height:12px; background:#ffaa00; transform:rotate(45deg); border:2px solid #fff;"></div>',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    marker = L.marker([settlement.lat, settlement.lon], {icon: diamondIcon}).addTo(map);
                } else {
                    // Circle for regular settlements
                    marker = L.circleMarker([settlement.lat, settlement.lon], {
                        radius: 3,
                        fillColor: '#444',
                        color: '#666',
                        weight: 1,
                        opacity: 0.7,
                        fillOpacity: 0.6
                    }).addTo(map);
                }

                const railwayInfo = settlement.railways
                    ? settlement.railways.map(r => `${r.railway} (${r.year})`).join(', ')
                    : 'No railway data';
                const junctionLabel = isMultiRailway ? '<b style="color:#ffaa00;">â—† Railway Junction</b><br>' : '';
                marker.bindPopup(`<b>${name}</b><br>${junctionLabel}${railwayInfo}<br><em>Click to explore</em>`);
                marker.on('click', () => {
                    selectSettlement(name);
                });

                allMarkers[name] = marker;
            });
        }

        // Initialize settlement selector dropdown
        function initSettlementSelector() {
            const datalist = document.getElementById('settlementList');
            const settlementNames = Object.keys(data.settlements).sort();

            settlementNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                datalist.appendChild(option);
            });

            const searchInput = document.getElementById('settlementSearch');
            searchInput.addEventListener('change', (e) => {
                const name = e.target.value;
                if (data.settlements[name]) {
                    selectSettlement(name);
                }
            });

            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const name = e.target.value;
                    if (data.settlements[name]) {
                        selectSettlement(name);
                    }
                }
            });
        }

        // Select a settlement and update the map
        function selectSettlement(name) {
            currentSettlement = name;
            previousYear = null;
            const settlement = data.settlements[name];
            const connections = data.connections[name] || [];

            // Update search input
            document.getElementById('settlementSearch').value = name;

            // Update selected info with all railways
            document.getElementById('selectedName').textContent = name;

            let railwaysHTML = '<p style="margin-top: 10px;">Railways: ';
            if (settlement.railways && settlement.railways.length > 0) {
                const currentYear = parseInt(document.getElementById('yearSlider').value);
                settlement.railways.forEach(r => {
                    const isFuture = r.year > currentYear;
                    railwaysHTML += `<span class="railway-tag ${isFuture ? 'future' : ''}">${r.railway} (${r.year})</span>`;
                });
            } else if (settlement.first_railway) {
                railwaysHTML += `<span class="railway-tag">${settlement.first_railway} (${settlement.railway_arrives || '?'})</span>`;
            } else {
                railwaysHTML += '<span style="color: #666;">No railway</span>';
            }
            railwaysHTML += '</p>';
            document.getElementById('selectedRailways').innerHTML = railwaysHTML;

            // Clear existing nearby markers, rings, and lines
            Object.values(nearbyMarkers).forEach(m => {
                if (m.marker) map.removeLayer(m.marker);
                if (m.ring) map.removeLayer(m.ring);
            });
            nearbyMarkers = {};
            connectionLines.forEach(line => map.removeLayer(line));
            connectionLines = [];
            if (selectedMarker) map.removeLayer(selectedMarker);
            if (radiusCircle) map.removeLayer(radiusCircle);

            // Reset all markers to default style and visibility
            Object.entries(allMarkers).forEach(([n, marker]) => {
                const isMultiRailway = hasMultipleRailways(n);
                if (isMultiRailway) {
                    // divIcon markers - use setOpacity
                    marker.setOpacity(1);
                } else {
                    // circleMarkers - use setStyle
                    marker.setStyle({
                        radius: 3,
                        fillColor: '#444',
                        color: '#666',
                        weight: 1,
                        opacity: 0.7,
                        fillOpacity: 0.6
                    });
                }
            });

            // Hide the selected settlement's background marker
            if (allMarkers[name]) {
                const isMultiRailway = hasMultipleRailways(name);
                if (isMultiRailway) {
                    allMarkers[name].setOpacity(0);
                } else {
                    allMarkers[name].setStyle({ opacity: 0, fillOpacity: 0 });
                }
            }

            // Center map on selected settlement
            map.setView([settlement.lat, settlement.lon], 9);

            // Add selected settlement marker (larger, red)
            const selectedIcon = L.divIcon({
                className: 'custom-marker',
                html: '<div style="background:#e94560; width:24px; height:24px; border-radius:50%; border:3px solid white; box-shadow: 0 0 10px rgba(233,69,96,0.5);"></div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            selectedMarker = L.marker([settlement.lat, settlement.lon], {icon: selectedIcon})
                .addTo(map)
                .bindPopup(`<b>${name}</b><br>First railway: ${settlement.railway_arrives || 'None'} (${settlement.first_railway || 'N/A'})`);

            // Make selected marker clickable to re-select/re-center
            selectedMarker.on('click', () => {
                selectSettlement(name);
            });

            // Add 40km radius circle
            radiusCircle = L.circle([settlement.lat, settlement.lon], {
                radius: 40000,
                color: '#e94560',
                fillColor: '#e94560',
                fillOpacity: 0.05,
                dashArray: '10, 10',
                weight: 2
            }).addTo(map);

            // Add larger markers for settlements within 40km
            connections.forEach(conn => {
                const connSettlement = data.settlements[conn.to];
                if (!connSettlement) return;

                // Hide background marker
                if (allMarkers[conn.to]) {
                    allMarkers[conn.to].setStyle({ opacity: 0, fillOpacity: 0 });
                }

                const isMultiRailway = hasMultipleRailways(conn.to);
                const railwayCount = getRailwayCount(conn.to);

                const marker = L.circleMarker([connSettlement.lat, connSettlement.lon], {
                    radius: 10,
                    fillColor: '#666',
                    color: '#fff',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.8
                }).addTo(map);

                // Add outer ring for multi-railway settlements
                let ring = null;
                if (isMultiRailway) {
                    ring = L.circleMarker([connSettlement.lat, connSettlement.lon], {
                        radius: 15,
                        fillColor: 'transparent',
                        color: '#ffaa00',
                        weight: 3,
                        opacity: 0.9,
                        fillOpacity: 0
                    }).addTo(map);
                }

                let railwayInfo = conn.shared_railway
                    ? `Shared Railway: ${conn.shared_railway}<br>Connected: ${conn.connected_year}`
                    : 'No shared railway';

                if (conn.all_shared_railways) {
                    railwayInfo += '<br>Also: ' + conn.all_shared_railways.slice(1).map(r =>
                        `${r.railway} (${r.connected_year})`).join(', ');
                }

                // Show all railways for this settlement
                const allRailways = connSettlement.railways
                    ? connSettlement.railways.map(r => `${r.railway} (${r.year})`).join(', ')
                    : '';
                const multiInfo = isMultiRailway ? `<br><b>Junction:</b> ${allRailways}` : '';

                const railwayDist = conn.railway_distance_km;
                const distanceDisplay = railwayDist != null && railwayDist > 0
                    ? `Direct: ${conn.distance_km} km | By rail: ${railwayDist} km`
                    : `Distance: ${conn.distance_km} km`;

                marker.bindPopup(`
                    <b>${conn.to}</b>${isMultiRailway ? ' <span style="color:#ffaa00;">â˜…</span>' : ''}<br>
                    ${distanceDisplay}<br>
                    ${railwayInfo}${multiInfo}<br>
                    <em>Click to explore</em>
                `);

                marker.on('click', () => {
                    setTimeout(() => selectSettlement(conn.to), 100);
                });

                nearbyMarkers[conn.to] = {
                    marker,
                    ring,
                    data: conn,
                    settlement: connSettlement,
                    isMultiRailway
                };
            });

            // Update for current year
            updateYear(parseInt(document.getElementById('yearSlider').value));
        }

        // Update visualization for selected year
        function updateYear(year) {
            document.getElementById('yearDisplay').textContent = year;
            document.getElementById('yearSlider').value = year;

            if (!currentSettlement) return;

            const connections = data.connections[currentSettlement] || [];
            const selectedSettlement = data.settlements[currentSettlement];

            // Update railway tags based on year
            if (selectedSettlement.railways) {
                let railwaysHTML = '<p style="margin-top: 10px;">Railways: ';
                selectedSettlement.railways.forEach(r => {
                    const isFuture = r.year > year;
                    railwaysHTML += `<span class="railway-tag ${isFuture ? 'future' : ''}">${r.railway} (${r.year})</span>`;
                });
                railwaysHTML += '</p>';
                document.getElementById('selectedRailways').innerHTML = railwaysHTML;
            }

            let connectedCount = 0;
            let pendingCount = 0;
            let newCount = 0;
            let listHTML = '';

            const connectedSettlements = [];
            const newSettlements = [];
            const pendingSettlements = [];

            // Clear existing connection lines
            connectionLines.forEach(line => map.removeLayer(line));
            connectionLines = [];

            // Check if selected settlement has railway by this year
            const selectedHasRailway = selectedSettlement.railway_arrives && selectedSettlement.railway_arrives <= year;

            connections.forEach(conn => {
                const m = nearbyMarkers[conn.to];
                if (!m) return;

                const isConnected = conn.connected_year && conn.connected_year <= year && selectedHasRailway;
                const isNewThisYear = conn.connected_year === year && selectedHasRailway;

                if (isConnected) {
                    connectedCount++;

                    if (isNewThisYear) {
                        newCount++;
                        newSettlements.push(conn);
                        // Yellow for new connections
                        m.marker.setStyle({
                            fillColor: '#ffcc00',
                            color: '#fff',
                            opacity: 1,
                            fillOpacity: 1,
                            radius: 12
                        });
                    } else {
                        connectedSettlements.push(conn);
                        // Green for established connections
                        m.marker.setStyle({
                            fillColor: '#4ecca3',
                            color: '#fff',
                            opacity: 1,
                            fillOpacity: 0.9,
                            radius: 10
                        });
                    }

                    // Draw connection using actual railway path
                    const connSettlement = data.settlements[conn.to];
                    const color = isNewThisYear ? '#ffcc00' : '#4ecca3';
                    const weight = isNewThisYear ? 4 : 3;
                    const opacity = isNewThisYear ? 0.9 : 0.7;

                    // Try to draw actual railway path
                    let line = drawRailwayConnection(currentSettlement, conn.to, color, weight, opacity);

                    // Fallback to straight line if path not found
                    if (!line) {
                        line = L.polyline(
                            [[selectedSettlement.lat, selectedSettlement.lon],
                             [connSettlement.lat, connSettlement.lon]],
                            {
                                color: color,
                                weight: weight - 1,
                                opacity: opacity * 0.7,
                                dashArray: '5, 5'
                            }
                        );
                    }

                    line.addTo(map);
                    connectionLines.push(line);
                } else {
                    pendingCount++;
                    pendingSettlements.push(conn);
                    m.marker.setStyle({
                        fillColor: '#888',
                        color: '#aaa',
                        opacity: 0.6,
                        fillOpacity: 0.6,
                        radius: 8
                    });
                }
            });

            // Sort by distance
            newSettlements.sort((a, b) => a.distance_km - b.distance_km);
            connectedSettlements.sort((a, b) => a.distance_km - b.distance_km);
            pendingSettlements.sort((a, b) => a.distance_km - b.distance_km);

            // Helper function to format distance display
            function formatDistance(conn) {
                const railDist = conn.railway_distance_km;
                if (railDist != null && railDist > 0) {
                    return `${conn.distance_km} km direct / ${railDist} km by rail`;
                }
                return `${conn.distance_km} km`;
            }

            // Build list HTML - new connections first (highlighted)
            newSettlements.forEach(conn => {
                listHTML += `
                    <div class="settlement-item new-connection" onclick="selectSettlement('${conn.to}')">
                        <div class="name">${conn.to}<span class="new-badge">NEW</span></div>
                        <div class="details">
                            ${formatDistance(conn)} | ${conn.shared_railway} (${conn.connected_year})
                        </div>
                    </div>
                `;
            });

            // Then established connections
            connectedSettlements.forEach(conn => {
                listHTML += `
                    <div class="settlement-item" onclick="selectSettlement('${conn.to}')">
                        <div class="name">${conn.to}</div>
                        <div class="details">
                            ${formatDistance(conn)} | ${conn.shared_railway} (${conn.connected_year})
                        </div>
                    </div>
                `;
            });

            // Then pending
            pendingSettlements.forEach(conn => {
                const reason = conn.shared_railway
                    ? `Connects ${conn.connected_year}`
                    : 'No shared railway';
                listHTML += `
                    <div class="settlement-item pending" onclick="selectSettlement('${conn.to}')">
                        <div class="name">${conn.to}</div>
                        <div class="details">
                            ${conn.distance_km} km | ${reason}
                        </div>
                    </div>
                `;
            });

            document.getElementById('totalCount').textContent = connections.length;
            document.getElementById('connectedCount').textContent = connectedCount;
            document.getElementById('newCount').textContent = newCount;
            document.getElementById('pendingCount').textContent = pendingCount;

            const listElement = document.getElementById('settlementListItems');
            if (connections.length === 0) {
                listElement.innerHTML = '<div class="no-connections">No settlements within 40 km</div>';
            } else {
                listElement.innerHTML = listHTML || '<div class="no-connections">No connected settlements yet</div>';
            }

            previousYear = year;
        }

        // Play animation
        function togglePlay() {
            if (isPlaying) {
                clearInterval(playInterval);
                document.getElementById('playBtn').textContent = 'Play';
                isPlaying = false;
            } else {
                isPlaying = true;
                document.getElementById('playBtn').textContent = 'Pause';
                let year = parseInt(document.getElementById('yearSlider').value);

                playInterval = setInterval(() => {
                    year += 1;
                    if (year > 1920) {
                        clearInterval(playInterval);
                        document.getElementById('playBtn').textContent = 'Play';
                        isPlaying = false;
                        return;
                    }
                    updateYear(year);
                }, 800);
            }
        }

        // Reset to 1882
        function reset() {
            if (isPlaying) {
                togglePlay();
            }
            updateYear(1882);
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadData();

            document.getElementById('yearSlider').addEventListener('input', (e) => {
                updateYear(parseInt(e.target.value));
            });

            document.getElementById('playBtn').addEventListener('click', togglePlay);
            document.getElementById('resetBtn').addEventListener('click', reset);
        });
    </script>
</body>
</html>
